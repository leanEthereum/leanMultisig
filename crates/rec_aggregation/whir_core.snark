import "fiat_shamir.snark";

const N_VARS = N_VARS_PLACEHOLDER;
const LOG_INV_RATE = LOG_INV_RATE_PLACEHOLDER; 

const FOLDING_FACTORS = FOLDING_FACTORS_PLACEHOLDER;

const FINAL_VARS = FINAL_VARS_PLACEHOLDER;

const RS_REDUCTION_FACTORS = RS_REDUCTION_FACTORS_PLACEHOLDER;

const NUM_OOD_COMMIT = NUM_OOD_COMMIT_PLACEHOLDER;
const NUM_OODS = NUM_OODS_PLACEHOLDER;

const GRINDING_BITS = GRINDING_BITS_PLACEHOLDER;

fn whir_recursion(transcript_start) {
    mut fs = fs_new(transcript_start);

    fs, mut root, ood_points_commit, ood_evals_commit = parse_whir_commitment_const(fs, NUM_OOD_COMMIT);

    // In the future point / eval will come from the PIOP
    fs, pcs_point = fs_hint(fs, N_VARS * DIM);
    fs, pcs_eval = fs_hint(fs, 5);

    combination_randomness_gen_0 = fs_sample_ef(fs);
    combination_randomness_powers_0 = powers(combination_randomness_gen_0, NUM_OOD_COMMIT + 1);

    claimed_sum_0_0 = malloc(DIM);
    dot_product(ood_evals_commit, combination_randomness_powers_0, claimed_sum_0_0, NUM_OOD_COMMIT, EE);
    claimed_sum_0_1 = mul_extension_ret(combination_randomness_powers_0 + NUM_OOD_COMMIT * DIM, pcs_eval);
    mut claimed_sum = add_extension_ret(claimed_sum_0_0, claimed_sum_0_1);

    all_folding_randomness = malloc(N_ROUNDS + 2);
    all_ood_points = malloc(N_ROUNDS);
    all_circle_values = malloc(N_ROUNDS + 1);
    all_combination_randomness_powers = malloc(N_ROUNDS);

    mut domain_sz = N_VARS + LOG_INV_RATE;
    for r in 0..N_ROUNDS unroll {
        var is_first_round;
        if r == 0 { is_first_round = 1; } else { is_first_round = 0; }
        fs, all_folding_randomness[r], all_ood_points[r], root, all_circle_values[r], all_combination_randomness_powers[r], claimed_sum =
        whir_round(fs, root, FOLDING_FACTORS[r], 2**FOLDING_FACTORS[r], is_first_round, NUM_QUERIES[r], domain_sz, claimed_sum, GRINDING_BITS[r], NUM_OODS[r]);
        domain_sz -= RS_REDUCTION_FACTORS[r];
    }

    fs, all_folding_randomness[N_ROUNDS], claimed_sum = sumcheck_verify(fs, FOLDING_FACTORS[N_ROUNDS], claimed_sum, 2);

    fs, final_coeffcients = fs_receive_ef(fs, 2**FINAL_VARS);

    fs, all_circle_values[N_ROUNDS], final_folds =
        sample_stir_indexes_and_fold(fs, NUM_QUERIES[N_ROUNDS], 0, FOLDING_FACTORS[N_ROUNDS], 2**FOLDING_FACTORS[N_ROUNDS], domain_sz, root, all_folding_randomness[N_ROUNDS], GRINDING_BITS[N_ROUNDS]);

    final_circle_values = all_circle_values[N_ROUNDS];
    for i in 0..NUM_QUERIES[N_ROUNDS] {
        powers_of_2_rev = expand_from_univariate_base_const(final_circle_values[i], FINAL_VARS);
        poly_eq = poly_eq_base(powers_of_2_rev, FINAL_VARS);
        final_pol_evaluated_on_circle = malloc(DIM);
        dot_product(poly_eq, final_coeffcients, final_pol_evaluated_on_circle, 2**FINAL_VARS, BE);
        copy_5(final_pol_evaluated_on_circle, final_folds + i*DIM);
    }

    fs, all_folding_randomness[N_ROUNDS + 1], end_sum = sumcheck_verify(fs, FINAL_VARS, claimed_sum, 2);

    folding_randomness_global = malloc(N_VARS * DIM);

    mut start = folding_randomness_global;
    for i in 0..N_ROUNDS + 1 unroll {
        for j in 0..FOLDING_FACTORS[i] unroll {
            copy_5(all_folding_randomness[i] + j*DIM, start + j*DIM);
        }
        start += FOLDING_FACTORS[i] * DIM;
    }
    for j in 0..FINAL_VARS unroll {
        copy_5(all_folding_randomness[N_ROUNDS + 1] + j*DIM, start + j*DIM);
    }

    all_ood_recovered_evals = malloc(NUM_OOD_COMMIT * DIM);
    for i in 0..NUM_OOD_COMMIT unroll {
        expanded_from_univariate = expand_from_univariate_ext(ood_points_commit + i * DIM, N_VARS);
        ood_rec = eq_mle_extension(expanded_from_univariate, folding_randomness_global, N_VARS);
        copy_5(ood_rec, all_ood_recovered_evals + i * DIM);
    }
    mut s = malloc(DIM);
    dot_product(all_ood_recovered_evals, combination_randomness_powers_0, s, NUM_OOD_COMMIT, EE);

    s2 = eq_mle_extension(pcs_point, folding_randomness_global, N_VARS);
    s3 = mul_extension_ret(s2, combination_randomness_powers_0 + NUM_OOD_COMMIT * DIM);
    s = add_extension_ret(s, s3);

    mut n_vars = N_VARS;
    mut my_folding_randomness = folding_randomness_global;
    for i in 0..N_ROUNDS unroll {
        n_vars -= FOLDING_FACTORS[i];
        my_ood_recovered_evals = malloc(NUM_OODS[i] * DIM);
        combination_randomness_powers = all_combination_randomness_powers[i];
        my_folding_randomness += FOLDING_FACTORS[i]*DIM;
        for j in 0..NUM_OODS[i] unroll {
            expanded_from_univariate = expand_from_univariate_ext(all_ood_points[i] + j * DIM, n_vars);
            ood_rec = eq_mle_extension(expanded_from_univariate, my_folding_randomness, n_vars);
            copy_5(ood_rec, my_ood_recovered_evals + j * DIM);
        }
        summed_ood = malloc(DIM);
        dot_product_ee_dynamic(my_ood_recovered_evals, combination_randomness_powers, summed_ood, NUM_OODS[i]);

        s6s = malloc((NUM_QUERIES[i]) * DIM);
        circle_value_i = all_circle_values[i];
        for j in 0..NUM_QUERIES[i] { // unroll ?
            expanded_from_univariate = expand_from_univariate_base(circle_value_i[j], n_vars);
            temp = eq_mle_extension_base(expanded_from_univariate, my_folding_randomness, n_vars);
            copy_5(temp, s6s + j * DIM);
        }
        s7 = malloc(DIM);
        dot_product(s6s, combination_randomness_powers + NUM_OODS[i] * DIM, s7, NUM_QUERIES[i], EE);
        s = add_extension_ret(s, s7);
        s = add_extension_ret(summed_ood, s);
    }
    poly_eq_final = poly_eq_extension(all_folding_randomness[N_ROUNDS + 1], FINAL_VARS);
    final_value = malloc(DIM);
    dot_product(poly_eq_final, final_coeffcients, final_value, 2**FINAL_VARS, EE);
    copy_5(mul_extension_ret(s, final_value), end_sum);

    fs = duplexing(fs);

    return;
}

fn sumcheck_verify(fs_state, n_steps, claimed_sum, const degree) -> 3 {
    challenges = malloc(n_steps * DIM);
    new_state, new_claimed_sum = sumcheck_verify_helper(fs_state, n_steps, claimed_sum, degree, challenges);
    return new_state, challenges, new_claimed_sum;
}

fn sumcheck_verify_helper(fs_state, n_steps, claimed_sum, const degree, challenges) -> 2 {
    fs_states_a = malloc(n_steps + 1);
    fs_states_a[0] = fs_state;

    claimed_sums = malloc(n_steps + 1);
    claimed_sums[0] = claimed_sum;

    for sc_round in 0..n_steps {
        fs_states_a[sc_round + 1], poly = fs_receive_ef(fs_states_a[sc_round], degree + 1);
        sum_over_boolean_hypercube = polynomial_sum_at_0_and_1(poly, degree);
        copy_5(sum_over_boolean_hypercube, claimed_sums[sc_round]);
        rand = fs_sample_ef(fs_states_a[sc_round + 1]);
        claimed_sums[sc_round + 1] = univariate_polynomial_eval(poly, rand, degree);
        copy_5(rand, challenges + sc_round * DIM);
    }

    new_state = fs_states_a[n_steps];
    new_claimed_sum = claimed_sums[n_steps];

    return new_state, new_claimed_sum;
}

fn sample_stir_indexes_and_fold(mut fs, num_queries, merkle_leaves_in_basefield, folding_factor, two_pow_folding_factor, domain_size, prev_root, folding_randomness, grinding_bits) -> 3 {

    folded_domain_size = domain_size - folding_factor;

    fs = fs_grinding(fs, grinding_bits);
    fs, stir_challenges_indexes = sample_bits_dynamic(fs, num_queries, folded_domain_size);

    answers = malloc(num_queries); // a vector of pointers, each pointing to `two_pow_folding_factor` field elements (base if first rounds, extension otherwise)
    fs_states_b = malloc(num_queries + 1);
    fs_states_b[0] = fs;

    var n_chunks_per_answer;
    // the number of chunk of 8 field elements per merkle leaf opened
    if merkle_leaves_in_basefield == 1 {
        n_chunks_per_answer = two_pow_folding_factor;
    } else {
        n_chunks_per_answer = two_pow_folding_factor * DIM;
    }

    for i in 0..num_queries {
        fs_states_b[i + 1], answer = fs_hint(fs_states_b[i], n_chunks_per_answer);
        answers[i] = answer;
    }
    fs = fs_states_b[num_queries];

    leaf_hashes = malloc(num_queries); // a vector of vectorized pointers, each pointing to 1 chunk of 8 field elements
    batch_hash_slice(num_queries, answers, leaf_hashes, n_chunks_per_answer / VECTOR_LEN);

    fs, merkle_paths = fs_hint(fs, folded_domain_size * num_queries * VECTOR_LEN);

    // Merkle verification
    merkle_verif_batch(num_queries, merkle_paths, leaf_hashes, stir_challenges_indexes, prev_root, folded_domain_size, num_queries);

    folds = malloc(num_queries * DIM);

    poly_eq = poly_eq_extension_dynamic(folding_randomness, folding_factor);

    if merkle_leaves_in_basefield == 1 {
        for i in 0..num_queries {
            dot_product(answers[i], poly_eq, folds + i*DIM, 2**FOLDING_FACTORS[0], BE);
        }
    } else {
        for i in 0..num_queries {
            dot_product_ee_dynamic(answers[i], poly_eq, folds + i*DIM, two_pow_folding_factor);
        }
    }

    circle_values = malloc(num_queries); // ROOT^each_stir_index
    for i in 0..num_queries {
        stir_index_bits = stir_challenges_indexes[i];
        circle_value = unit_root_pow_dynamic(folded_domain_size, stir_index_bits);
        circle_values[i] = circle_value;
    }

    return fs, circle_values, folds;
}

fn whir_round(mut fs, prev_root, folding_factor, two_pow_folding_factor, merkle_leaves_in_basefield, num_queries, domain_size, claimed_sum, grinding_bits, num_ood) -> 7 {
    fs, folding_randomness, new_claimed_sum_a = sumcheck_verify(fs, folding_factor, claimed_sum, 2);

    fs, root, ood_points, ood_evals = parse_commitment(fs, num_ood);

    fs, circle_values, folds =
        sample_stir_indexes_and_fold(fs, num_queries, merkle_leaves_in_basefield, folding_factor, two_pow_folding_factor, domain_size, prev_root, folding_randomness, grinding_bits);

    combination_randomness_gen = fs_sample_ef(fs);

    combination_randomness_powers = powers(combination_randomness_gen, num_queries + num_ood);

    claimed_sum_0 = malloc(DIM);
    dot_product_ee_dynamic(ood_evals, combination_randomness_powers, claimed_sum_0, num_ood);

    claimed_sum_1 = malloc(DIM);
    dot_product_ee_dynamic(folds, combination_randomness_powers + num_ood * DIM, claimed_sum_1, num_queries);

    new_claimed_sum_b = add_extension_ret(claimed_sum_0, claimed_sum_1);

    final_sum = add_extension_ret(new_claimed_sum_a, new_claimed_sum_b);

    return fs, folding_randomness, ood_points, root, circle_values, combination_randomness_powers, final_sum;
}

fn polynomial_sum_at_0_and_1(coeffs, const degree) -> 1 {
    debug_assert 1 < degree;

    res = malloc(DIM * (1 + degree));
    add_extension(coeffs, coeffs, res); // constant coefficient is doubled
    for i in 0..degree unroll {
        add_extension(res + i * DIM, coeffs + (i + 1) * DIM, res + (i + 1) * DIM); // TODO use the dot_product precompile
    }
    return res + degree * DIM;
}


fn parse_commitment(mut fs, num_ood) -> 4 {
    var root;
    var ood_points;
    var ood_evals;
    debug_assert num_ood < 4;
    debug_assert num_ood != 0;
    match num_ood {
        0 => {  } // unreachable
        1 => { fs, root, ood_points, ood_evals = parse_whir_commitment_const(fs, 1); }
        2 => { fs, root, ood_points, ood_evals = parse_whir_commitment_const(fs, 2); }
        3 => { fs, root, ood_points, ood_evals = parse_whir_commitment_const(fs, 3); }
        4 => { fs, root, ood_points, ood_evals = parse_whir_commitment_const(fs, 4); }
    }
    return fs, root, ood_points, ood_evals;
}

fn parse_whir_commitment_const(mut fs, const num_ood) -> 4 {
    fs, root = fs_receive_chunks(fs, 1);
    ood_points = malloc(num_ood * DIM);
    for i in 0..num_ood unroll {
        ood_point = fs_sample_ef(fs);
        copy_5(ood_point, ood_points + i * DIM);
        fs = duplexing(fs);
    }
    fs, ood_evals = fs_receive_ef(fs, num_ood);
    return fs, root, ood_points, ood_evals;
}
