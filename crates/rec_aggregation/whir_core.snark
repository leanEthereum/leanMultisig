import "fiat_shamir.snark";

const N_VARS = N_VARS_PLACEHOLDER;
const LOG_INV_RATE = LOG_INV_RATE_PLACEHOLDER; 

const FOLDING_FACTORS = FOLDING_FACTORS_PLACEHOLDER;

const FINAL_VARS = FINAL_VARS_PLACEHOLDER;

const RS_REDUCTION_FACTORS = RS_REDUCTION_FACTORS_PLACEHOLDER;

const NUM_OOD_COMMIT = NUM_OOD_COMMIT_PLACEHOLDER;
const NUM_OODS = NUM_OODS_PLACEHOLDER;

const GRINDING_BITS = GRINDING_BITS_PLACEHOLDER;

fn whir_recursion(transcript_start) {
    fs_state = fs_new(transcript_start);
    all_roots = malloc(N_ROUNDS + 1);

    fs_0, all_roots[0], ood_points_commit, ood_evals_commit = parse_whir_commitment_const(fs_state, NUM_OOD_COMMIT);

    // In the future point / eval will come from the PIOP
    fs_1, pcs_point = fs_hint(fs_0, N_VARS * DIM);
    fs_3, pcs_eval = fs_hint(fs_1, 5);

    fs_4, combination_randomness_gen_0 = fs_sample_ef(fs_3);
    combination_randomness_powers_0 = powers(combination_randomness_gen_0, NUM_OOD_COMMIT + 1);

    all_claimed_sums = malloc(N_ROUNDS + 2);

    claimed_sum_0_0 = malloc(DIM);
    dot_product(ood_evals_commit, combination_randomness_powers_0, claimed_sum_0_0, NUM_OOD_COMMIT, EE);
    claimed_sum_0_1 = mul_extension_ret(combination_randomness_powers_0 + NUM_OOD_COMMIT * DIM, pcs_eval);
    all_claimed_sums[0] = add_extension_ret(claimed_sum_0_0, claimed_sum_0_1);
    
    domain_size = malloc(N_ROUNDS + 1);
    domain_size[0] = N_VARS + LOG_INV_RATE;
    for i in 0..N_ROUNDS unroll { domain_size[i + 1] = domain_size[i] - RS_REDUCTION_FACTORS[i]; }

    is_first_round = malloc(N_ROUNDS);
    is_first_round[0] = 1;
    for i in 1..N_ROUNDS unroll { is_first_round[i] = 0; }

    all_folding_randomness = malloc(N_ROUNDS + 2);
    all_ood_points = malloc(N_ROUNDS);
    all_circle_values = malloc(N_ROUNDS + 1);
    all_combination_randomness_powers = malloc(N_ROUNDS);

    all_fs = malloc(N_ROUNDS + 1);
    all_fs[0] = fs_4;
    for r in 0..N_ROUNDS unroll {
        all_fs[r+1], all_folding_randomness[r], all_ood_points[r], all_roots[r+1], all_circle_values[r], all_combination_randomness_powers[r], all_claimed_sums[r+1] = 
        whir_round(all_fs[r], all_roots[r], FOLDING_FACTORS[r], 2**FOLDING_FACTORS[r], is_first_round[r], NUM_QUERIES[r], domain_size[r], all_claimed_sums[r], GRINDING_BITS[r], NUM_OODS[r]);
    }

    fs_8, all_folding_randomness[N_ROUNDS], all_claimed_sums[N_ROUNDS + 1] = sumcheck_verify(all_fs[N_ROUNDS], FOLDING_FACTORS[N_ROUNDS], all_claimed_sums[N_ROUNDS], 2);
    
    fs_9, final_coeffcients = fs_receive_ef(fs_8, 2**FINAL_VARS);

    fs_10, all_circle_values[N_ROUNDS], final_folds =
        sample_stir_indexes_and_fold(fs_9, NUM_QUERIES[N_ROUNDS], 0, FOLDING_FACTORS[N_ROUNDS], 2**FOLDING_FACTORS[N_ROUNDS], domain_size[N_ROUNDS], all_roots[N_ROUNDS], all_folding_randomness[N_ROUNDS], GRINDING_BITS[N_ROUNDS]);
    
    final_circle_values = all_circle_values[N_ROUNDS];
    for i in 0..NUM_QUERIES[N_ROUNDS] {
        powers_of_2_rev = expand_from_univariate_base_const(final_circle_values[i], FINAL_VARS);
        poly_eq = poly_eq_base(powers_of_2_rev, FINAL_VARS);
        final_pol_evaluated_on_circle = malloc(DIM);
        dot_product(poly_eq, final_coeffcients, final_pol_evaluated_on_circle, 2**FINAL_VARS, BE); 
        copy_5(final_pol_evaluated_on_circle, final_folds + i*DIM);
    }

    fs_11, all_folding_randomness[N_ROUNDS + 1], end_sum = sumcheck_verify(fs_10, FINAL_VARS, all_claimed_sums[N_ROUNDS + 1], 2);

    folding_randomness_global = malloc(N_VARS * DIM);

    ffs_sums = malloc(N_ROUNDS + 3);
    ffs_sums[0] = 0;
    for i in 0..N_ROUNDS + 1 unroll {
        ffs_sums[i + 1] = ffs_sums[i] + FOLDING_FACTORS[i];
    }
    ffs_sums[N_ROUNDS + 2] = ffs_sums[N_ROUNDS + 1] + FINAL_VARS;
    for i in 0..N_ROUNDS + 1 unroll {
        start = folding_randomness_global + ffs_sums[i] * DIM;
        for j in 0..FOLDING_FACTORS[i] unroll {
            copy_5(all_folding_randomness[i] + j*DIM, start + j*DIM);
        }
    }
    start = folding_randomness_global + ffs_sums[N_ROUNDS + 1] * DIM;
    for j in 0..FINAL_VARS unroll {
        copy_5(all_folding_randomness[N_ROUNDS + 1] + j*DIM, start + j*DIM);
    }

    all_ood_recovered_evals = malloc(NUM_OOD_COMMIT * DIM);
    for i in 0..NUM_OOD_COMMIT unroll {
        expanded_from_univariate = expand_from_univariate_ext(ood_points_commit + i * DIM, N_VARS);
        ood_rec = eq_mle_extension(expanded_from_univariate, folding_randomness_global, N_VARS);
        copy_5(ood_rec, all_ood_recovered_evals + i * DIM);
    }
    s1 = malloc(DIM);
    dot_product(all_ood_recovered_evals, combination_randomness_powers_0, s1, NUM_OOD_COMMIT, EE);

    s2 = eq_mle_extension(pcs_point, folding_randomness_global, N_VARS);
    s3 = mul_extension_ret(s2, combination_randomness_powers_0 + NUM_OOD_COMMIT * DIM);
    s4 = add_extension_ret(s1, s3);

    weight_sums = malloc(N_ROUNDS + 1);
    weight_sums[0] = s4;

    for i in 0..N_ROUNDS unroll {
        n_vars = N_VARS - ffs_sums[i+1];
        my_ood_recovered_evals = malloc(NUM_OODS[i] * DIM);
        combination_randomness_powers = all_combination_randomness_powers[i];
        my_folding_randomness = folding_randomness_global + ffs_sums[i+1]*DIM;
        for j in 0..NUM_OODS[i] unroll {
            expanded_from_univariate = expand_from_univariate_ext(all_ood_points[i] + j * DIM, n_vars);
            ood_rec = eq_mle_extension(expanded_from_univariate, my_folding_randomness, n_vars);
            copy_5(ood_rec, my_ood_recovered_evals + j * DIM);
        }
        summed_ood = malloc(DIM);
        dot_product_ee_dynamic(my_ood_recovered_evals, combination_randomness_powers, summed_ood, NUM_OODS[i]);

        s6s = malloc((NUM_QUERIES[i]) * DIM);
        circle_value_i = all_circle_values[i];
        for j in 0..NUM_QUERIES[i] { // unroll ?
            expanded_from_univariate = expand_from_univariate_base(circle_value_i[j], n_vars);
            temp = eq_mle_extension_base(expanded_from_univariate, my_folding_randomness, n_vars);
            copy_5(temp, s6s + j * DIM);
        }
        s7 = malloc(DIM);
        dot_product(s6s, combination_randomness_powers + NUM_OODS[i] * DIM, s7, NUM_QUERIES[i], EE);
        s8 = add_extension_ret(summed_ood, s7);
        s9 = add_extension_ret(weight_sums[i], s8);
        weight_sums[i+1] = s9;
    }
    evaluation_of_weights = weight_sums[N_ROUNDS]; // not good
    poly_eq_final = poly_eq_extension(all_folding_randomness[N_ROUNDS + 1], FINAL_VARS);
    final_value = malloc(DIM);
    dot_product(poly_eq_final, final_coeffcients, final_value, 2**FINAL_VARS, EE);
    evaluation_of_weights_times_final_value = mul_extension_ret(evaluation_of_weights, final_value);
    copy_5(evaluation_of_weights_times_final_value, end_sum);

    fs_final = duplexing(fs_11);
    
    return;
}

fn sumcheck_verify(fs_state, n_steps, claimed_sum, const degree) -> 3 {
    challenges = malloc(n_steps * DIM);
    new_state, new_claimed_sum = sumcheck_verify_helper(fs_state, n_steps, claimed_sum, degree, challenges);
    return new_state, challenges, new_claimed_sum;
}

fn sumcheck_verify_helper(fs_state, n_steps, claimed_sum, const degree, challenges) -> 2 {

    fs_states_a = malloc(n_steps + 1);
    fs_states_a[0] = fs_state;

    claimed_sums = malloc(n_steps + 1);
    claimed_sums[0] = claimed_sum;

    for sc_round in 0..n_steps {
        fs_5, poly = fs_receive_ef(fs_states_a[sc_round], degree + 1);
        sum_over_boolean_hypercube = polynomial_sum_at_0_and_1(poly, degree);
        copy_5(sum_over_boolean_hypercube, claimed_sums[sc_round]);
        fs_states_a[sc_round + 1], rand = fs_sample_ef(fs_5);
        claimed_sums[sc_round + 1] = univariate_polynomial_eval(poly, rand, degree);
        copy_5(rand, challenges + sc_round * DIM);
    }

    new_state = fs_states_a[n_steps];
    new_claimed_sum = claimed_sums[n_steps];

    return new_state, new_claimed_sum;
}

fn sample_stir_indexes_and_fold(fs_state, num_queries, merkle_leaves_in_basefield, folding_factor, two_pow_folding_factor, domain_size, prev_root, folding_randomness, grinding_bits) -> 3 {

    folded_domain_size = domain_size - folding_factor;

    fs_8 = fs_grinding(fs_state, grinding_bits);
    fs_9, stir_challenges_indexes = sample_bits_dynamic(fs_8, num_queries, folded_domain_size);

    answers = malloc(num_queries); // a vector of pointers, each pointing to `two_pow_folding_factor` field elements (base if first rounds, extension otherwise)
    fs_states_b = malloc(num_queries + 1);
    fs_states_b[0] = fs_9;
    
    var n_chunks_per_answer;
    // the number of chunk of 8 field elements per merkle leaf opened
    if merkle_leaves_in_basefield == 1 {
        n_chunks_per_answer = two_pow_folding_factor;
    } else {
        n_chunks_per_answer = two_pow_folding_factor * DIM;
    }

    for i in 0..num_queries {
        new_fs_state, answer = fs_hint(fs_states_b[i], n_chunks_per_answer); 
        fs_states_b[i + 1] = new_fs_state;
        answers[i] = answer;
    }
    fs_10 = fs_states_b[num_queries];

    leaf_hashes = malloc(num_queries); // a vector of vectorized pointers, each pointing to 1 chunk of 8 field elements
    batch_hash_slice(num_queries, answers, leaf_hashes, n_chunks_per_answer / VECTOR_LEN);

    fs_11, merkle_paths = fs_hint(fs_10, folded_domain_size * num_queries * VECTOR_LEN);

    // Merkle verification
    merkle_verif_batch(num_queries, merkle_paths, leaf_hashes, stir_challenges_indexes, prev_root, folded_domain_size, num_queries);

    folds = malloc(num_queries * DIM);

    poly_eq = poly_eq_extension_dynamic(folding_randomness, folding_factor);

    if merkle_leaves_in_basefield == 1 {
        for i in 0..num_queries {
            dot_product(answers[i], poly_eq, folds + i*DIM, 2**FOLDING_FACTORS[0], BE);
        }
    } else {
        for i in 0..num_queries {
            dot_product_ee_dynamic(answers[i], poly_eq, folds + i*DIM, two_pow_folding_factor);
        }
    }

    circle_values = malloc(num_queries); // ROOT^each_stir_index
    for i in 0..num_queries {
        stir_index_bits = stir_challenges_indexes[i];
        circle_value = unit_root_pow_dynamic(folded_domain_size, stir_index_bits);
        circle_values[i] = circle_value;
    }

    return fs_11, circle_values, folds;
}

fn whir_round(fs_state, prev_root, folding_factor, two_pow_folding_factor, merkle_leaves_in_basefield, num_queries, domain_size, claimed_sum, grinding_bits, num_ood) -> 7 {
    fs_7, folding_randomness, new_claimed_sum_a = sumcheck_verify(fs_state, folding_factor, claimed_sum, 2);

    fs_8, root, ood_points, ood_evals = parse_commitment(fs_7, num_ood);

    fs_11, circle_values, folds = 
        sample_stir_indexes_and_fold(fs_8, num_queries, merkle_leaves_in_basefield, folding_factor, two_pow_folding_factor, domain_size, prev_root, folding_randomness, grinding_bits);

    fs_12, combination_randomness_gen = fs_sample_ef(fs_11);

    combination_randomness_powers = powers(combination_randomness_gen, num_queries + num_ood);

    claimed_sum_0 = malloc(DIM);
    dot_product_ee_dynamic(ood_evals, combination_randomness_powers, claimed_sum_0, num_ood);
    
    claimed_sum_1 = malloc(DIM);
    dot_product_ee_dynamic(folds, combination_randomness_powers + num_ood * DIM, claimed_sum_1, num_queries);

    new_claimed_sum_b = add_extension_ret(claimed_sum_0, claimed_sum_1);

    final_sum = add_extension_ret(new_claimed_sum_a, new_claimed_sum_b);

    return fs_12, folding_randomness, ood_points, root, circle_values, combination_randomness_powers, final_sum;
}

fn polynomial_sum_at_0_and_1(coeffs, const degree) -> 1 {
    debug_assert 1 < degree;

    res = malloc(DIM * (1 + degree));
    add_extension(coeffs, coeffs, res); // constant coefficient is doubled
    for i in 0..degree unroll {
        add_extension(res + i * DIM, coeffs + (i + 1) * DIM, res + (i + 1) * DIM); // TODO use the dot_product precompile
    }
    return res + degree * DIM;
}


fn parse_commitment(fs_state, num_ood) -> 4 {
    var fs_4;
    var root;
    var ood_points;
    var ood_evals;
    debug_assert num_ood < 4;
    debug_assert num_ood != 0;
    match num_ood {
        0 => {  } // unreachable
        1 => { fs_4, root, ood_points, ood_evals = parse_whir_commitment_const(fs_state, 1); }
        2 => { fs_4, root, ood_points, ood_evals = parse_whir_commitment_const(fs_state, 2); }
        3 => { fs_4, root, ood_points, ood_evals = parse_whir_commitment_const(fs_state, 3); }
        4 => { fs_4, root, ood_points, ood_evals = parse_whir_commitment_const(fs_state, 4); }
    }
    return fs_4, root, ood_points, ood_evals;
}

fn parse_whir_commitment_const(fs_state, const num_ood) -> 4 {
    fs_1, root = fs_receive_chunks(fs_state, 1);
    ood_points = malloc(num_ood * DIM);
    all_fs = malloc(num_ood + 1);
    all_fs[0] = fs_1;
    for i in 0..num_ood unroll {
        next_fs, ood_point = fs_sample_ef(all_fs[i]);
        copy_5(ood_point, ood_points + i * DIM);
        duplexed = duplexing(next_fs);
        all_fs[i + 1] = duplexed;
    }
    fs_4, ood_evals = fs_receive_ef(all_fs[num_ood], num_ood);
    return fs_4, root, ood_points, ood_evals;
}
