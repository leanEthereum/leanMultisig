const COMPRESSION = 1;
const PERMUTATION = 0;

const V = 66;
const W = 4;
const TARGET_SUM = 118;

const V_HALF = V / 2; // V should be even

fn main() {
    public_input_start_ = public_input_start;
    n_signatures = public_input_start_[0];
    sig_size = public_input_start_[1]; // vectorized
    message_hash = public_input_start / 8 + 1;
    all_public_keys = message_hash + 1;
    all_log_lifetimes = (all_public_keys + n_signatures) * 8;
    all_merkle_indexes = all_log_lifetimes + n_signatures;

    signatures_start_no_vec = private_input_start();
    signatures_start = signatures_start_no_vec / 8;
    for i in 0..n_signatures {
        xmss_public_key = all_public_keys + i;
        signature = signatures_start + i * sig_size;
        log_lifetime = all_log_lifetimes[i];
        merkle_index = all_merkle_indexes[i];
        xmss_public_key_recovered = xmss_recover_pub_key(message_hash, signature, log_lifetime, merkle_index);
        assert_eq_vec(xmss_public_key, xmss_public_key_recovered);
    }
    return;
}

fn xmss_recover_pub_key(message_hash, signature, log_lifetime, merkle_index) -> 1 {
    // message_hash: vectorized pointers (of length 1)
    // signature: vectorized pointer = randomness | chain_tips
    // return a vectorized pointer (of length 1), the hashed xmss public key
    randomness = signature; // vectorized
    chain_tips = signature + 1; // vectorized

    // 1) We encode message_hash + randomness into the d-th layer of the hypercube

    compressed = malloc_vec(1);
    poseidon16(message_hash, randomness, compressed, COMPRESSION);
    compressed_ptr = compressed * 8;
    compressed_vals = malloc(6);
    dot_product_ee(compressed_ptr, pointer_to_one_vector * 8, compressed_vals, 1);
    compressed_vals[5] = compressed_ptr[5];

    encoding = malloc(12 * 6);
    remaining = malloc(6);

    hint_decompose_bits_xmss(encoding, remaining, compressed_vals[0], compressed_vals[1], compressed_vals[2], compressed_vals[3], compressed_vals[4], compressed_vals[5]);

    // check that the decomposition is correct
    for i in 0..6 unroll {
        for j in 0..12 unroll {
            // TODO Implem range check (https://github.com/leanEthereum/leanMultisig/issues/52)
            // For now we use dummy instructions to replicate exactly the cost

            // assert encoding[i * 12 + j] < 4;
            dummy_0 = 88888888;
            assert dummy_0 == 88888888;
            assert dummy_0 == 88888888;
            assert dummy_0 == 88888888;
        }

        // assert remaining[i] < 2^7 - 1;
        dummy_1 = 88888888;
        dummy_2 = 88888888;
        dummy_3 = 88888888;
        assert dummy_1 == 88888888;
        assert dummy_2 == 88888888;
        assert dummy_3 == 88888888;

        partial_sums = malloc(13);
        partial_sums[0] = remaining[i] * 2**24;
        for j in 1..13 unroll {
            partial_sums[j] = partial_sums[j - 1] + encoding[i * 12 + (j-1)] * 4**(j-1);
        }
        assert partial_sums[12] == compressed_vals[i];
    }
    
    // we need to check the target sum
    sums = malloc(V);
    sums[0] = encoding[0];
    for i in 1..V unroll {
        sums[i] = sums[i - 1] + encoding[i];
    }
    assert sums[V - 1] == TARGET_SUM;

    public_key = malloc_vec(V);

    chain_tips_ptr = 8 * chain_tips;
    public_key_ptr = 8 * public_key;

    for i in 0..V unroll {
        match encoding[i] {
            0 => {
                var_1 = chain_tips + i;
                var_2 = public_key + i;
                var_3 = malloc_vec(1);
                var_4 = malloc_vec(1);
                poseidon16(var_1, pointer_to_zero_vector, var_3, COMPRESSION);
                poseidon16(var_3, pointer_to_zero_vector, var_4, COMPRESSION);
                poseidon16(var_4, pointer_to_zero_vector, var_2, COMPRESSION);
            }
            1 => {
                var_3 = malloc_vec(1);
                var_1 = chain_tips + i;
                var_2 = public_key + i;
                poseidon16(var_1, pointer_to_zero_vector, var_3, COMPRESSION);
                poseidon16(var_3, pointer_to_zero_vector, var_2, COMPRESSION);
            }
            2 => {
                var_1 = chain_tips + i;
                var_2 = public_key + i;
                poseidon16(var_1, pointer_to_zero_vector, var_2, COMPRESSION);
            }
            3 => {
                var_1 = chain_tips_ptr + (i * 8);
                var_2 = public_key_ptr + (i * 8);
                var_3 = var_1 + 3;
                var_4 = var_2 + 3;
                dot_product_ee(var_1, pointer_to_one_vector * 8, var_2, 1);
                dot_product_ee(var_3, pointer_to_one_vector * 8, var_4, 1);
            }
        }
    }

    wots_pubkey_hashed = malloc_vec(1);
    slice_hash(pointer_to_zero_vector, public_key, wots_pubkey_hashed, V_HALF);

    debug_assert log_lifetime < 33;

    merkle_root = malloc_vec(1);
    match log_lifetime {
        0 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 0); }
        1 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 1); }
        2 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 2); }
        3 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 3); }
        4 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 4); }
        5 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 5); }
        6 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 6); }
        7 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 7); }
        8 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 8); }
        9 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 9); }
        10 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 10); }
        11 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 11); }
        12 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 12); }
        13 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 13); }
        14 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 14); }
        15 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 15); }
        16 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 16); }
        17 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 17); }
        18 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 18); }
        19 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 19); }
        20 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 20); }
        21 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 21); }
        22 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 22); }
        23 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 23); }
        24 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 24); }
        25 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 25); }
        26 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 26); }
        27 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 27); }
        28 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 28); }
        29 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 29); }
        30 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 30); }
        31 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 31); }
        32 => { merkle_verify(wots_pubkey_hashed, merkle_index, merkle_root, 32); }
    }           
    

    return merkle_root;
}

fn assert_eq_vec(x, y) inline {
    // x and y are vectorized pointer of len 1 each
    ptr_x = x * 8;
    ptr_y = y * 8;
    dot_product_ee(ptr_x, pointer_to_one_vector * 8, ptr_y, 1);
    dot_product_ee(ptr_x + 3, pointer_to_one_vector * 8, ptr_y + 3, 1);
    return;
}
