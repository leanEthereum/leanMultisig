
// 1 OOD QUERY PER ROUND -> TODO
// 0 GRINDING IN SUMCHECK -> TODO

const COMPRESSION = 1;
const PERMUTATION = 0;

const F_BITS = 31; // koala-bear = 31 bits
const DIM = 5; // extension degree

const N_VARS = N_VARS_PLACEHOLDER;
const LOG_INV_RATE = LOG_INV_RATE_PLACEHOLDER; 
const N_ROUNDS = 3; // TODO make it a parameter

const FOLDING_FACTOR_0 = FOLDING_FACTOR_0_PLACEHOLDER;
const FOLDING_FACTOR_1 = FOLDING_FACTOR_1_PLACEHOLDER;
const FOLDING_FACTOR_2 = FOLDING_FACTOR_2_PLACEHOLDER;
const FOLDING_FACTOR_3 = FOLDING_FACTOR_3_PLACEHOLDER;

const FINAL_VARS = N_VARS - (FOLDING_FACTOR_0 + FOLDING_FACTOR_1 + FOLDING_FACTOR_2 + FOLDING_FACTOR_3);

const RS_REDUCTION_FACTOR_0 = RS_REDUCTION_FACTOR_0_PLACEHOLDER;
const RS_REDUCTION_FACTOR_1 = 1;
const RS_REDUCTION_FACTOR_2 = 1;
const RS_REDUCTION_FACTOR_3 = 1;

const NUM_QUERIES_0 = NUM_QUERIES_0_PLACEHOLDER;
const NUM_QUERIES_1 = NUM_QUERIES_1_PLACEHOLDER;
const NUM_QUERIES_2 = NUM_QUERIES_2_PLACEHOLDER;
const NUM_QUERIES_3 = NUM_QUERIES_3_PLACEHOLDER;

const GRINDING_BITS_0 = GRINDING_BITS_0_PLACEHOLDER;
const GRINDING_BITS_1 = GRINDING_BITS_1_PLACEHOLDER;
const GRINDING_BITS_2 = GRINDING_BITS_2_PLACEHOLDER;
const GRINDING_BITS_3 = GRINDING_BITS_3_PLACEHOLDER;

const MERKLE_HEIGHT_0 = N_VARS + LOG_INV_RATE - FOLDING_FACTOR_0;
const MERKLE_HEIGHT_1 = N_VARS + LOG_INV_RATE - FOLDING_FACTOR_1 - RS_REDUCTION_FACTOR_0;
const MERKLE_HEIGHT_2 = MERKLE_HEIGHT_1 - RS_REDUCTION_FACTOR_1;
const MERKLE_HEIGHT_3 = MERKLE_HEIGHT_2 - RS_REDUCTION_FACTOR_2;

const TWO_ADICITY = 24;
const ROOT = 1791270792; // of order 2^TWO_ADICITY

const N_RECURSIONS = N_RECURSIONS_PLACEHOLDER;
const WHIR_PROOF_SIZE = WHIR_PROOF_SIZE_PLACEHOLDER;

const VECTOR_LEN = 8;

fn main() {
    for i in 0..N_RECURSIONS unroll {
        whir_recursion(public_input_start + i * WHIR_PROOF_SIZE);
    }
    return;
}

fn whir_recursion(transcript_start) {
    fs_state = fs_new(transcript_start);

    fs_0, root_0, ood_point_0, ood_eval_0 = parse_commitment(fs_state);

    // In the future point / eval will come from the PIOP
    fs_1, pcs_point = fs_hint(fs_0, N_VARS * DIM);
    fs_3, pcs_eval = fs_hint(fs_1, 5);

    fs_4, combination_randomness_gen_0 = fs_sample_ef(fs_3);

    claimed_sum_side = mul_extension_ret(combination_randomness_gen_0, pcs_eval);
    claimed_sum_0 = add_extension_ret(ood_eval_0, claimed_sum_side);
    domain_size_0 = N_VARS + LOG_INV_RATE;
    fs_5, folding_randomness_1, ood_point_1, root_1, circle_values_1, combination_randomness_powers_1, claimed_sum_1 = 
        whir_round(fs_4, root_0, FOLDING_FACTOR_0, 2**FOLDING_FACTOR_0, 1, NUM_QUERIES_0, domain_size_0, claimed_sum_0, GRINDING_BITS_0);

    domain_size_1 = domain_size_0 - RS_REDUCTION_FACTOR_0;
    fs_6, folding_randomness_2, ood_point_2, root_2, circle_values_2, combination_randomness_powers_2, claimed_sum_2 = 
        whir_round(fs_5, root_1, FOLDING_FACTOR_1, 2**FOLDING_FACTOR_1, 0, NUM_QUERIES_1, domain_size_1, claimed_sum_1, GRINDING_BITS_1);

    domain_size_2 = domain_size_1 - RS_REDUCTION_FACTOR_1;
    fs_7, folding_randomness_3, ood_point_3, root_3, circle_values_3, combination_randomness_powers_3, claimed_sum_3 = 
        whir_round(fs_6, root_2, FOLDING_FACTOR_2, 2**FOLDING_FACTOR_2, 0, NUM_QUERIES_2, domain_size_2, claimed_sum_2, GRINDING_BITS_2);

    domain_size_3 = domain_size_2 - RS_REDUCTION_FACTOR_2;
    fs_8, folding_randomness_4, final_claimed_sum = sumcheck(fs_7, FOLDING_FACTOR_3, claimed_sum_3);
    
    fs_9, final_coeffcients = fs_receive_ef(fs_8, 2**FINAL_VARS);

    fs_10, final_circle_values, final_folds =
        sample_stir_indexes_and_fold(fs_9, NUM_QUERIES_3, 0, FOLDING_FACTOR_3, 2**FOLDING_FACTOR_3, domain_size_3, root_3, folding_randomness_4, GRINDING_BITS_3);
    
    for i in 0..NUM_QUERIES_3 {
        powers_of_2_rev = expand_from_univariate_base_const(final_circle_values[i], FINAL_VARS);
        poly_eq = poly_eq_base(powers_of_2_rev, FINAL_VARS);
        final_pol_evaluated_on_circle = malloc(DIM);
        dot_product_be(poly_eq, final_coeffcients, final_pol_evaluated_on_circle, 2**FINAL_VARS); 
        copy_5(final_pol_evaluated_on_circle, final_folds + i*DIM);
    }

    fs_11, folding_randomness_5, end_sum = sumcheck(fs_10, FINAL_VARS, final_claimed_sum);

    folding_randomness_global = malloc(N_VARS * DIM);

    ffs = malloc(N_ROUNDS + 2);
    ffs[0] = FOLDING_FACTOR_0; ffs[1] = FOLDING_FACTOR_1; ffs[2] = FOLDING_FACTOR_2; ffs[3] = FOLDING_FACTOR_3; ffs[4] = FINAL_VARS;
    frs = malloc(N_ROUNDS + 2);
    frs[0] = folding_randomness_1; frs[1] = folding_randomness_2; frs[2] = folding_randomness_3; frs[3] = folding_randomness_4; frs[4] = folding_randomness_5;
    ffs_sums = malloc(N_ROUNDS + 3);
    ffs_sums[0] = 0;
    for i in 0..N_ROUNDS + 2 {
        ffs_sums[i + 1] = ffs_sums[i] + ffs[i];
    }
    for i in 0..N_ROUNDS + 2 {
        start = folding_randomness_global + ffs_sums[i] * DIM;
        for j in 0..ffs[i] {
            copy_5(frs[i] + j*DIM, start + j*DIM);
        }
    }

    ood_0_expanded_from_univariate = expand_from_univariate_ext(ood_point_0, N_VARS);
    s0 = eq_mle_extension(ood_0_expanded_from_univariate, folding_randomness_global, N_VARS);
    s1 = eq_mle_extension(pcs_point, folding_randomness_global, N_VARS);
    s3 = mul_extension_ret(s1, combination_randomness_gen_0);
    s4 = add_extension_ret(s0, s3);

    weight_sums = malloc(N_ROUNDS + 1);
    weight_sums[0] = s4;

    ood_points = malloc(N_ROUNDS + 1); ood_points[0] = ood_point_0; ood_points[1] = ood_point_1; ood_points[2] = ood_point_2; ood_points[3] = ood_point_3;
    num_queries = malloc(N_ROUNDS + 1); num_queries[0] = NUM_QUERIES_0; num_queries[1] = NUM_QUERIES_1; num_queries[2] = NUM_QUERIES_2; num_queries[3] = NUM_QUERIES_3;
    circle_values = malloc(N_ROUNDS + 1); circle_values[0] = circle_values_1; circle_values[1] = circle_values_2; circle_values[2] = circle_values_3; circle_values[3] = final_circle_values;
    combination_randomness_powers = malloc(N_ROUNDS); combination_randomness_powers[0] = combination_randomness_powers_1; combination_randomness_powers[1] = combination_randomness_powers_2; combination_randomness_powers[2] = combination_randomness_powers_3;

    for i in 0..N_ROUNDS {
        ood_expanded_from_univariate = expand_from_univariate_ext(ood_points[i + 1], N_VARS - ffs_sums[i+1]);
        s5 = eq_mle_extension(ood_expanded_from_univariate, folding_randomness_global + ffs_sums[i+1]*DIM, N_VARS - ffs_sums[i+1]);
        s6s = malloc((num_queries[i] + 1) * DIM);
        copy_5(s5, s6s);
        circle_value_i = circle_values[i];
        for j in 0..num_queries[i] {
            expanded_from_univariate = expand_from_univariate_base(circle_value_i[j], N_VARS - ffs_sums[i+1]);
            temp = eq_mle_extension_base(expanded_from_univariate, folding_randomness_global + ffs_sums[i+1]*DIM, N_VARS - ffs_sums[i+1]);
            copy_5(temp, s6s + (j + 1) * DIM);
        }
        s7 = malloc(DIM);
        dot_product_ee_dynamic(s6s, combination_randomness_powers[i], s7, num_queries[i] + 1);
        wsum = add_extension_ret(weight_sums[i], s7);
        weight_sums[i+1] = wsum;
    }
    evaluation_of_weights = weight_sums[N_ROUNDS]; // not good
    poly_eq_final = poly_eq_extension(folding_randomness_5, FINAL_VARS, 2**FINAL_VARS);
    final_value = malloc(DIM);
    dot_product_ee(poly_eq_final, final_coeffcients, final_value, 2**FINAL_VARS);
    evaluation_of_weights_times_final_value = mul_extension_ret(evaluation_of_weights, final_value);
    copy_5(evaluation_of_weights_times_final_value, end_sum);

    fs_final = duplexing(fs_11);
    
    return;
}

fn eq_mle_extension(a, b, n) -> 1 {

    buff = malloc(n*DIM);

    for i in 0..n {
        shift = i * DIM;
        ai = a + shift;
        bi = b + shift;
        buffi = buff + shift;
        ab = mul_extension_ret(ai, bi);
        buffi[0] = 1 + 2 * ab[0] - ai[0] - bi[0];
        for j in 1..DIM unroll {
            buffi[j] = 2 * ab[j] - ai[j] - bi[j];
        }
    }

    prods = malloc(n*DIM);
    copy_5(buff, prods);
    for i in 0..n - 1 {
        mul_extension(prods + i*DIM, buff + (i + 1)*DIM, prods + (i + 1)*DIM);
    }

    return prods + (n - 1) * DIM;
}

fn eq_mle_extension_base(a, b, n) -> 1 {
    var res;
    debug_assert n < 23;
    match n {
        0 => {  } // unreachable
        1 => { res = eq_mle_extension_base_const(a, b, 1); }
        2 => { res = eq_mle_extension_base_const(a, b, 2); }
        3 => { res = eq_mle_extension_base_const(a, b, 3); }
        4 => { res = eq_mle_extension_base_const(a, b, 4); }
        5 => { res = eq_mle_extension_base_const(a, b, 5); }
        6 => { res = eq_mle_extension_base_const(a, b, 6); }
        7 => { res = eq_mle_extension_base_const(a, b, 7); }
        8 => { res = eq_mle_extension_base_const(a, b, 8); }
        9 => { res = eq_mle_extension_base_const(a, b, 9); }
        10 => { res = eq_mle_extension_base_const(a, b, 10); }
        11 => { res = eq_mle_extension_base_const(a, b, 11); }
        12 => { res = eq_mle_extension_base_const(a, b, 12); }
        13 => { res = eq_mle_extension_base_const(a, b, 13); }
        14 => { res = eq_mle_extension_base_const(a, b, 14); }
        15 => { res = eq_mle_extension_base_const(a, b, 15); }
        16 => { res = eq_mle_extension_base_const(a, b, 16); }
        17 => { res = eq_mle_extension_base_const(a, b, 17); }
        18 => { res = eq_mle_extension_base_const(a, b, 18); }
        19 => { res = eq_mle_extension_base_const(a, b, 19); }
        20 => { res = eq_mle_extension_base_const(a, b, 20); }
        21 => { res = eq_mle_extension_base_const(a, b, 21); }
        22 => { res = eq_mle_extension_base_const(a, b, 22); }
    }
    return res;
}

fn eq_mle_extension_base_const(a, b, const n) -> 1 {
    // a: base
    // b: extension

    buff = malloc(n*DIM);

    for i in 0..n unroll {
        ai = a[i];
        bi = b + i*DIM;
        buffi = buff + i*DIM;
        ai_double = ai * 2;
        buffi[0] = 1 + ai_double * bi[0] - ai - bi[0];
        for j in 1..DIM unroll {
            buffi[j] = ai_double * bi[j] - bi[j];
        }
    }

    prods = malloc(n*DIM);
    copy_5(buff, prods);
    for i in 0..n - 1 unroll {
        mul_extension(prods + i*DIM, buff + (i + 1)*DIM, prods + (i + 1)*DIM);
    }
    return prods + (n - 1) * DIM;
}

fn expand_from_univariate_base(alpha, n) -> 1 {
    var res;
    debug_assert n < 23;
    match n {
        0 => {  } // unreachable
        1 => { res = expand_from_univariate_base_const(alpha, 1); }
        2 => { res = expand_from_univariate_base_const(alpha, 2); }
        3 => { res = expand_from_univariate_base_const(alpha, 3); }
        4 => { res = expand_from_univariate_base_const(alpha, 4); }
        5 => { res = expand_from_univariate_base_const(alpha, 5); }
        6 => { res = expand_from_univariate_base_const(alpha, 6); }
        7 => { res = expand_from_univariate_base_const(alpha, 7); }
        8 => { res = expand_from_univariate_base_const(alpha, 8); }
        9 => { res = expand_from_univariate_base_const(alpha, 9); }
        10 => { res = expand_from_univariate_base_const(alpha, 10); }
        11 => { res = expand_from_univariate_base_const(alpha, 11); }
        12 => { res = expand_from_univariate_base_const(alpha, 12); }
        13 => { res = expand_from_univariate_base_const(alpha, 13); }
        14 => { res = expand_from_univariate_base_const(alpha, 14); }
        15 => { res = expand_from_univariate_base_const(alpha, 15); }
        16 => { res = expand_from_univariate_base_const(alpha, 16); }
        17 => { res = expand_from_univariate_base_const(alpha, 17); }
        18 => { res = expand_from_univariate_base_const(alpha, 18); }
        19 => { res = expand_from_univariate_base_const(alpha, 19); }
        20 => { res = expand_from_univariate_base_const(alpha, 20); }
        21 => { res = expand_from_univariate_base_const(alpha, 21); }
        22 => { res = expand_from_univariate_base_const(alpha, 22); }
    }
    return res;
}

fn expand_from_univariate_base_const(alpha, const n) -> 1 {
    // "expand_from_univariate"
    // alpha: F

    res = malloc(n);
    res[0] = alpha;
    for i in 0..n-1 unroll {
        res[i+1] = res[i] * res[i];
    }
    return res;
}

fn expand_from_univariate_ext(alpha, n) -> 1 {
    res = malloc(n*DIM);
    copy_5(alpha, res);
    for i in 0..n-1 {
        mul_extension(res + i*DIM, res + i*DIM, res + (i + 1)*DIM);
    }
    return res;
}

fn sumcheck(fs_state, n_steps, claimed_sum) -> 3 {

    fs_states_a = malloc(n_steps + 1);
    fs_states_a[0] = fs_state;

    claimed_sums = malloc(n_steps + 1);
    claimed_sums[0] = claimed_sum;

    folding_randomness = malloc(n_steps * DIM);

    for sc_round in 0..n_steps {
        fs_5, poly = fs_receive_ef(fs_states_a[sc_round], 3);
        sum_over_boolean_hypercube = degree_two_polynomial_sum_at_0_and_1(poly);
        copy_5(sum_over_boolean_hypercube, claimed_sums[sc_round]);
        fs_6, rand = fs_sample_ef(fs_5);
        fs_states_a[sc_round + 1] = fs_6;
        new_claimed_sum = degree_two_polynomial_eval(poly, rand);
        claimed_sums[sc_round + 1] = new_claimed_sum;
        copy_5(rand, folding_randomness + sc_round * DIM);
    }

    new_state = fs_states_a[n_steps];
    new_claimed_sum = claimed_sums[n_steps];

    return new_state, folding_randomness, new_claimed_sum;
}

fn sample_stir_indexes_and_fold(fs_state, num_queries, merkle_leaves_in_basefield, folding_factor, two_pow_folding_factor, domain_size, prev_root, folding_randomness, grinding_bits) -> 3 {

    folded_domain_size = domain_size - folding_factor;

    fs_8 = fs_grinding(fs_state, grinding_bits);
    fs_9, stir_challenges_indexes = sample_bits_dynamic(fs_8, num_queries, folded_domain_size);

    answers = malloc(num_queries); // a vector of pointers, each pointing to `two_pow_folding_factor` field elements (base if first rounds, extension otherwise)
    fs_states_b = malloc(num_queries + 1);
    fs_states_b[0] = fs_9;
    
    var n_chunks_per_answer;
    // the number of chunk of 8 field elements per merkle leaf opened
    if merkle_leaves_in_basefield == 1 {
        n_chunks_per_answer = two_pow_folding_factor;
    } else {
        n_chunks_per_answer = two_pow_folding_factor * DIM;
    }

    for i in 0..num_queries {
        new_fs_state, answer = fs_hint(fs_states_b[i], n_chunks_per_answer); 
        fs_states_b[i + 1] = new_fs_state;
        answers[i] = answer;
    }
    fs_10 = fs_states_b[num_queries];

    leaf_hashes = malloc(num_queries); // a vector of vectorized pointers, each pointing to 1 chunk of 8 field elements
    batch_hash_slice(num_queries, answers, leaf_hashes, n_chunks_per_answer / VECTOR_LEN);

    fs_11, merkle_paths = fs_hint(fs_10, folded_domain_size * num_queries * VECTOR_LEN);

    // Merkle verification
    merkle_verif_batch(num_queries, merkle_paths, leaf_hashes, stir_challenges_indexes, prev_root, folded_domain_size, num_queries);

    folds = malloc(num_queries * DIM);

    poly_eq = poly_eq_extension(folding_randomness, folding_factor, two_pow_folding_factor);

    if merkle_leaves_in_basefield == 1 {
        for i in 0..num_queries {
            dot_product_be(answers[i], poly_eq, folds + i*DIM, 2**FOLDING_FACTOR_0);
        }
    } else {
        for i in 0..num_queries {
            dot_product_ee_dynamic(answers[i], poly_eq, folds + i*DIM, two_pow_folding_factor);
        }
    }

    circle_values = malloc(num_queries); // ROOT^each_stir_index
    for i in 0..num_queries {
        stir_index_bits = stir_challenges_indexes[i];
        circle_value = unit_root_pow_dynamic(folded_domain_size, stir_index_bits);
        circle_values[i] = circle_value;
    }

    return fs_11, circle_values, folds;
}

fn batch_hash_slice(num_queries, all_data_to_hash, all_resulting_hashes, len) {
    if len == DIM * 2 {
        batch_hash_slice_const(num_queries, all_data_to_hash, all_resulting_hashes, DIM);
        return;
    }
    if len == 16 {
        batch_hash_slice_const(num_queries, all_data_to_hash, all_resulting_hashes, 8);
        return;
    }
    TODO_batch_hash_slice = len;
    print(77777123);
    print(TODO_batch_hash_slice);
    panic();
}

fn batch_hash_slice_const(num_queries, all_data_to_hash, all_resulting_hashes, const half_len) {
    for i in 0..num_queries {
        data = all_data_to_hash[i];
        res = slice_hash(pointer_to_zero_vector, data, half_len);
        all_resulting_hashes[i] = res;
    }
    return;    
}

fn slice_hash(seed, data, const half_len) -> 1 {
    states = malloc(half_len * 2 * VECTOR_LEN);
    poseidon16(pointer_to_zero_vector, data, states, COMPRESSION);
    state_indexes = malloc(half_len * 2);
    state_indexes[0] = states;
    for j in 1..(half_len * 2) unroll {
        state_indexes[j] = state_indexes[j-1] + VECTOR_LEN;
        poseidon16(state_indexes[j-1], data + j * VECTOR_LEN, state_indexes[j], COMPRESSION);
    }
    return state_indexes[half_len * 2 - 1];
}

fn merkle_verif_batch(n_paths, merkle_paths, leaves_digests, leave_positions, root, height, num_queries) {
    if height + num_queries * 1000 == MERKLE_HEIGHT_0 + NUM_QUERIES_0 * 1000 {
        merkle_verif_batch_const(NUM_QUERIES_0, merkle_paths, leaves_digests, leave_positions, root, MERKLE_HEIGHT_0);
        return;
    }
    if height + num_queries * 1000 == MERKLE_HEIGHT_1 + NUM_QUERIES_1 * 1000 {
        merkle_verif_batch_const(NUM_QUERIES_1, merkle_paths,leaves_digests, leave_positions, root, MERKLE_HEIGHT_1);
        return;
    }
    if height + num_queries * 1000 == MERKLE_HEIGHT_2 + NUM_QUERIES_2 * 1000 {
        merkle_verif_batch_const(NUM_QUERIES_2, merkle_paths, leaves_digests, leave_positions, root, MERKLE_HEIGHT_2);
        return;
    }
    if height + num_queries * 1000 == MERKLE_HEIGHT_3 + NUM_QUERIES_3 * 1000 {
        merkle_verif_batch_const(NUM_QUERIES_3, merkle_paths, leaves_digests, leave_positions, root, MERKLE_HEIGHT_3);
        return;
    }

    print(12345555);
    print(height);
    panic();
}

fn merkle_verif_batch_const(const n_paths, merkle_paths, leaves_digests, leave_positions, root, const height) {
    // n_paths: F
    // leaves_digests: pointer to a slice of n_paths vectorized pointers, each pointing to 1 chunk of 8 field elements
    // leave_positions: pointer to a slice of n_paths field elements (each < 2^height)
    // root: vectorized pointer to 1 chunk of 8 field elements
    // height: F

    for i in 0..n_paths unroll {
        merkle_verify(leaves_digests[i], merkle_paths + (i * height) * VECTOR_LEN, leave_positions[i], root, height);
    }

    return;
}


fn merkle_verify(leaf_digest, merkle_path, leaf_position_bits, root, const height) {
    states = malloc(height * VECTOR_LEN);
    
    // First merkle round
    match leaf_position_bits[0] {
        0 => { poseidon16(leaf_digest, merkle_path, states, COMPRESSION); }
        1 => { poseidon16(merkle_path, leaf_digest, states, COMPRESSION); }
    }

    // Remaining merkle rounds
    state_indexes = malloc(height);
    state_indexes[0] = states;
    for j in 1..height unroll {
        state_indexes[j] = state_indexes[j-1] + VECTOR_LEN;
        // Warning: this works only if leaf_position_bits[i] is known to be boolean:
        match leaf_position_bits[j] {
            0 => { poseidon16(state_indexes[j-1], merkle_path + j * VECTOR_LEN, state_indexes[j], COMPRESSION); }
            1 => { poseidon16(merkle_path + j * VECTOR_LEN, state_indexes[j-1], state_indexes[j], COMPRESSION); }
        }
    }
    copy_8(state_indexes[height - 1], root);
    return;
}

fn whir_round(fs_state, prev_root, folding_factor, two_pow_folding_factor, merkle_leaves_in_basefield, num_queries, domain_size, claimed_sum, grinding_bits) -> 7 {
    fs_7, folding_randomness, new_claimed_sum_a = sumcheck(fs_state, folding_factor, claimed_sum);

    fs_8, root, ood_point, ood_eval = parse_commitment(fs_7);

    fs_11, circle_values, folds = 
        sample_stir_indexes_and_fold(fs_8, num_queries, merkle_leaves_in_basefield, folding_factor, two_pow_folding_factor, domain_size, prev_root, folding_randomness, grinding_bits);

    fs_12, combination_randomness_gen = fs_sample_ef(fs_11);

    combination_randomness_powers = powers(combination_randomness_gen, num_queries + 1); // "+ 1" because of one OOD sample

    claimed_sum_supplement_side = malloc(5);
    dot_product_ee_dynamic(folds, combination_randomness_powers + DIM, claimed_sum_supplement_side, num_queries);

    claimed_sum_supplement = add_extension_ret(claimed_sum_supplement_side, ood_eval);
    new_claimed_sum_b = add_extension_ret(claimed_sum_supplement, new_claimed_sum_a);

    return fs_12, folding_randomness, ood_point, root, circle_values, combination_randomness_powers, new_claimed_sum_b;
}

fn copy_chunk(src, dst) {
    // src: pointer to 8 F
    // dst: pointer to 8 F
    for i in 0..8 unroll { dst[i] = src[i]; }
    return;
}

fn copy_chunk_vec(src, dst) {
    zero = 0; // TODO
    add_extension(src, zero, dst);
    return;
}

fn powers(alpha, n) -> 1 {
    // alpha: EF
    // n: F

    res = malloc(n * DIM);
    set_to_one(res);
    for i in 0..n - 1 {
        mul_extension(res + i*DIM, alpha, res + (i + 1)*DIM);
    }
    return res;
}

fn unit_root_pow_dynamic(domain_size, index_bits) -> 1 {
    // index_bits is a pointer to domain_size bits
    var res;
    match domain_size {
        0 => {  } // unreachable
        1 => { res = unit_root_pow_const(1, index_bits); }
        2 => { res = unit_root_pow_const(2, index_bits); }
        3 => { res = unit_root_pow_const(3, index_bits); }
        4 => { res = unit_root_pow_const(4, index_bits); }
        5 => { res = unit_root_pow_const(5, index_bits); }
        6 => { res = unit_root_pow_const(6, index_bits); }
        7 => { res = unit_root_pow_const(7, index_bits); }
        8 => { res = unit_root_pow_const(8, index_bits); }
        9 => { res = unit_root_pow_const(9, index_bits); }
        10 => { res = unit_root_pow_const(10, index_bits); }
        11 => { res = unit_root_pow_const(11, index_bits); }
        12 => { res = unit_root_pow_const(12, index_bits); }
        13 => { res = unit_root_pow_const(13, index_bits); }
        14 => { res = unit_root_pow_const(14, index_bits); }
        15 => { res = unit_root_pow_const(15, index_bits); }
        16 => { res = unit_root_pow_const(16, index_bits); }
        17 => { res = unit_root_pow_const(17, index_bits); }
        18 => { res = unit_root_pow_const(18, index_bits); }
        19 => { res = unit_root_pow_const(19, index_bits); }
        20 => { res = unit_root_pow_const(20, index_bits); }
        21 => { res = unit_root_pow_const(21, index_bits); }
        22 => { res = unit_root_pow_const(22, index_bits); }
    }
    return res;
}

fn unit_root_pow_const(const domain_size, index_bits) -> 1 {
    prods = malloc(domain_size);
    prods[0] = ((index_bits[0] * ROOT**(2**(TWO_ADICITY - domain_size))) + (1 - index_bits[0]));
    for i in 1..domain_size unroll {
        prods[i] = prods[i - 1] * ((index_bits[i] * ROOT**(2**(TWO_ADICITY - domain_size + i))) + (1 - index_bits[i]));
    }
    return prods[domain_size - 1];
}

fn dot_product_ee_dynamic(a, b, res, n) { 
    if n == 16 {
        dot_product_ee(a, b, res, 16);
        return;
    }

    dot_product_ee_dynamic_helper_1(a, b, res, n);
    return;
}

fn dot_product_ee_dynamic_helper_1(a, b, res, n) {
    if n == NUM_QUERIES_0 {
        dot_product_ee(a, b, res, NUM_QUERIES_0);
        return;
    }

    dot_product_ee_dynamic_helper_2(a, b, res, n);
    return;
}

fn dot_product_ee_dynamic_helper_2(a, b, res, n) {
    if n == NUM_QUERIES_1 {
        dot_product_ee(a, b, res, NUM_QUERIES_1);
        return;
    }
    if n == NUM_QUERIES_2 {
        dot_product_ee(a, b, res, NUM_QUERIES_2);
        return;
    }

    dot_product_ee_dynamic_helper_3(a, b, res, n);
    return;
}

fn dot_product_ee_dynamic_helper_3(a, b, res, n) {
    if n == NUM_QUERIES_3 {
        dot_product_ee(a, b, res, NUM_QUERIES_3);
        return;
    }
    if n == NUM_QUERIES_0 + 1 {
        dot_product_ee(a, b, res, NUM_QUERIES_0 + 1);
        return;
    }

    dot_product_ee_dynamic_helper_4(a, b, res, n);
    return;
}

fn dot_product_ee_dynamic_helper_4(a, b, res, n) {
    if n == NUM_QUERIES_1 + 1 {
        dot_product_ee(a, b, res, NUM_QUERIES_1 + 1);
        return;
    }
    if n == NUM_QUERIES_2 + 1 {
        dot_product_ee(a, b, res, NUM_QUERIES_2 + 1);
        return;
    }

    dot_product_ee_dynamic_helper_5(a, b, res, n);
    return;
}

fn dot_product_ee_dynamic_helper_5(a, b, res, n) {
    if n == NUM_QUERIES_3 + 1 {
        dot_product_ee(a, b, res, NUM_QUERIES_3 + 1);
        return;
    }

    TODO_dot_product_ee_dynamic = 0;
    print(TODO_dot_product_ee_dynamic, n);
    panic();
}

fn poly_eq_extension(point, n, two_pow_n) -> 1 {
    // Example: for n = 2: eq(x, y) = [(1 - x)(1 - y), (1 - x)y, x(1 - y), xy]

    if n == 0 {
        res = malloc(DIM);
        set_to_one(res);
        return res;
    } else {
        res = malloc(two_pow_n * DIM);

        inner_res = poly_eq_extension(point + DIM, n - 1, two_pow_n / 2);

        two_pow_n_minus_1 = two_pow_n / 2;

        for i in 0..two_pow_n_minus_1 {
            mul_extension(point, inner_res + i*DIM, res + (two_pow_n_minus_1 + i) * DIM);
            sub_extension(inner_res + i*DIM, res + (two_pow_n_minus_1 + i) * DIM, res + i*DIM);
        }
        
        return res;
    }
}

fn poly_eq_base(point, n) -> 1 {
    var res;
    match n {
        0 => {  } // unreachable
        1 => { res = poly_eq_base_1(point); }
        2 => { res = poly_eq_base_2(point); }
        3 => { res = poly_eq_base_3(point); }
        4 => { res = poly_eq_base_4(point); }
        5 => { res = poly_eq_base_5(point); }
        6 => { res = poly_eq_base_6(point); }
        7 => { res = poly_eq_base_7(point); }
    }
    return res;
}

fn poly_eq_base_7(point) -> 1 {
    // n = 7
    // return a (normal) pointer to 2^n base field elements, corresponding to the "equality polynomial" at point
    // Example: for n = 2: eq(x, y) = [(1 - x)(1 - y), (1 - x)y, x(1 - y), xy]

    res = malloc(128);

    inner_res = poly_eq_base_6(point + 1);

    for i in 0..64 unroll {
        res[64 + i] = inner_res[i] * point[0];
        res[i] = inner_res[i] - res[64 + i];
    }
    
    return res;
}

fn poly_eq_base_6(point) -> 1 {
    // n = 6
    res = malloc(64);
    
    inner_res = poly_eq_base_5(point + 1);
    
    for i in 0..32 unroll {
        res[32 + i] = inner_res[i] * point[0];
        res[i] = inner_res[i] - res[32 + i];
    }
    
    return res;
}

fn poly_eq_base_5(point) -> 1 {
    // n = 5
    res = malloc(32);
    
    inner_res = poly_eq_base_4(point + 1);
    
    for i in 0..16 unroll {
        res[16 + i] = inner_res[i] * point[0];
        res[i] = inner_res[i] - res[16 + i];
    }
    
    return res;
}

fn poly_eq_base_4(point) -> 1 {
    // n = 4
    res = malloc(16);
    
    inner_res = poly_eq_base_3(point + 1);
    
    for i in 0..8 unroll {
        res[8 + i] = inner_res[i] * point[0];
        res[i] = inner_res[i] - res[8 + i];
    }
    
    return res;
}

fn poly_eq_base_3(point) -> 1 {
    // n = 3
    res = malloc(8);
    
    inner_res = poly_eq_base_2(point + 1);
    
    for i in 0..4 unroll {
        res[4 + i] = inner_res[i] * point[0];
        res[i] = inner_res[i] - res[4 + i];
    }
    
    return res;
}

fn poly_eq_base_2(point) -> 1 {
    // n = 2
    res = malloc(4);
    
    inner_res = poly_eq_base_1(point + 1);
    
    for i in 0..2 unroll {
        res[2 + i] = inner_res[i] * point[0];
        res[i] = inner_res[i] - res[2 + i];
    }
    
    return res;
}

fn poly_eq_base_1(point) -> 1 {
    // n = 1
    // Base case: eq(x) = [1 - x, x]
    res = malloc(2);
    
    res[1] = point[0];
    res[0] = 1 - res[1];
    
    return res;
}


fn pow(a, b) -> 1 {
    if b == 0 {
        return 1; // a^0 = 1
    } else {
        p = pow(a, b - 1);
        return a * p;
    }
}

fn sample_bits_dynamic(fs_state, n_samples, K) -> 2 {
    var new_fs_state;
    var sampled_bits;
    if n_samples == NUM_QUERIES_0 {
        new_fs_state, sampled_bits = sample_bits_const(fs_state, NUM_QUERIES_0, K);
        return new_fs_state, sampled_bits;
    } else if n_samples == NUM_QUERIES_1 {
        new_fs_state, sampled_bits = sample_bits_const(fs_state, NUM_QUERIES_1, K);
        return new_fs_state, sampled_bits;
    } else if n_samples == NUM_QUERIES_2 {
        new_fs_state, sampled_bits = sample_bits_const(fs_state, NUM_QUERIES_2, K);
        return new_fs_state, sampled_bits;
    } else if n_samples == NUM_QUERIES_3 {
        new_fs_state, sampled_bits = sample_bits_const(fs_state, NUM_QUERIES_3, K);
        return new_fs_state, sampled_bits;
    }
    print(n_samples);
    print(999333);
    panic();
}

fn sample_bits_const(fs, const n_samples, K) -> 2 {
    // return the updated fiat-shamir, and a pointer to n pointers, each pointing to 31 (boolean) field elements,
    all_fs = malloc(1 + next_multiple_of(n_samples, 8) / 8);
    all_fs[0] = fs;
    for i in 0..next_multiple_of(n_samples, 8) / 8 unroll {
        duplexed = duplexing(all_fs[i]);
        all_fs[i + 1] = duplexed;
    }
    sampled_bits = malloc(n_samples);
    for i in 0..(next_multiple_of(n_samples, 8) / 8) - 1 unroll {
        my_fs = all_fs[i];
        for j in 0..8 unroll {
            bits, _ = checked_decompose_bits(my_fs[j], K);
            sampled_bits[i * 8 + j] = bits;
        }
    }
    // Last batch (may be partial)
    last_fs = all_fs[(next_multiple_of(n_samples, 8) / 8) - 1];
    for j in 0..(n_samples % 8) unroll {
        bits, _ = checked_decompose_bits(last_fs[j], K);
        sampled_bits[((next_multiple_of(n_samples, 8) / 8) - 1) * 8 + j] = bits;
    }
    final_fs = duplexing(last_fs);

    return final_fs, sampled_bits;
}

// p = 2^31 - 2^24 + 1
// in binary: p = 1111111000000000000000000000001
//        p - 1 = 1111111000000000000000000000000
//        p - 2 = 1111110111111111111111111111111
//        p - 3 = 1111110111111111111111111111110
//        ...
// Any field element (< p) is either:
// -   1111111    | 00...00
// - not(1111111) | xx...xx
fn checked_decompose_bits(a, k) -> 2 {
    // return a pointer to the 31 bits of a
    // .. and the partial value, reading the first K bits (with k <= 24)
    bits = decompose_bits(a); // hint

    for i in 0..F_BITS unroll {
        assert bits[i] * (1 - bits[i]) == 0;
    }
    sums_24_first_bits = malloc(24);
    sums_24_first_bits[0] = bits[0];
    for i in 1..24 unroll {
        sums_24_first_bits[i] = sums_24_first_bits[i - 1] + bits[i] * 2**i;
    }
    sums_7_last_bits = malloc(7);
    sums_7_last_bits[0] = bits[24];
    for i in 1..7 unroll {
        sums_7_last_bits[i] = sums_7_last_bits[i - 1] + bits[24 + i] * 2**i;
    }
    if sums_7_last_bits[6] == 127 {
        assert sums_24_first_bits[23] == 0;
    }

    assert a == sums_24_first_bits[23] + sums_7_last_bits[6] * 2**24;
    partial_sum = sums_24_first_bits[k - 1];
    return bits, partial_sum;
}

fn degree_two_polynomial_sum_at_0_and_1(coeffs) -> 1 {
    // coeffs is a normal pointer to 3 consecutive EF element
    // return a normal pointer to 1 ef element
    a = add_extension_ret(coeffs, coeffs);
    b = add_extension_ret(a, coeffs + DIM);
    c = add_extension_ret(b, coeffs + (DIM * 2));
    return c;
}

fn degree_two_polynomial_eval(coeffs, point) -> 1 {
    // coefs: normal pointer to 3 consecutive EF element
    // point: normal pointer to 1 EF element
    // return a normal pointer to 1 EF element
    point_squared = mul_extension_ret(point, point);
    a_xx = mul_extension_ret(coeffs + DIM * 2, point_squared);
    b_x = mul_extension_ret(coeffs + DIM, point);
    c = coeffs;
    res_0 = add_extension_ret(a_xx, b_x);
    res_1 = add_extension_ret(res_0, c);
    return res_1;
}

fn parse_commitment(fs_state) -> 4 {
    fs_1, root = fs_receive_chunks(fs_state, 1);
    fs_2, ood_point = fs_sample_ef(fs_1);
    fs_3 = duplexing(fs_2);
    fs_4, ood_eval = fs_receive_ef(fs_3, 1);
    return fs_4, root, ood_point, ood_eval;
}

// FIAT SHAMIR layout: 17 field elements
// 0..8 -> first half of sponge state
// 8..16 -> second half of sponge state
// 16 -> transcript pointer

fn fs_new(transcript_ptr) -> 1 {
    fs_state = malloc(17);
    set_to_16_zeros(fs_state);
    fs_state[16] = transcript_ptr;
    duplexed = duplexing(fs_state);
    return duplexed;
}

fn duplexing(fs) -> 1 {
    new_fs = malloc(17);
    poseidon16(fs, fs + 8, new_fs, PERMUTATION);
    new_fs[16] = fs[16];
    return new_fs;
}

fn fs_grinding(fs, bits) -> 1 {
    if bits == 0 {
        return fs; // no grinding
    }
    left = malloc(8);
    grinding_witness = read_memory(fs[16]);
    left[0] = grinding_witness;
    set_to_7_zeros(left + 1);

    fs_1 = malloc(17);
    poseidon16(left, fs + 8, fs_1, PERMUTATION);
    fs_1[16] = fs[16] + 1; // one element read from transcript

    sampled = fs_1[0];
    _, sampled_low_bits_value = checked_decompose_bits(sampled, bits);
    assert sampled_low_bits_value == 0;

    fs_2 = duplexing(fs_1);
    
    return fs_2;
}

fn fs_sample_ef(fs) -> 2 {
    return fs, fs;
}

fn fs_hint(fs, n) -> 2 {
    // return the updated fiat-shamir, and a pointer to n field elements from the transcript

    transcript_ptr = fs[16];
    new_fs = malloc(17);
    copy_16(fs, new_fs);
    new_fs[16] = fs[16] + n; // advance transcript pointer
    return new_fs, transcript_ptr;
}

fn fs_receive_chunks(fs, const n_chunks) -> 2 {
    // each chunk = 8 field elements
    new_fs = malloc(1 + 16 * n_chunks);
    transcript_ptr = fs[16];
    new_fs[16 * n_chunks] = transcript_ptr + 8 * n_chunks; // advance transcript pointer

    poseidon16(transcript_ptr, fs + 8, new_fs, PERMUTATION);
    for i in 1..n_chunks unroll {
        poseidon16(transcript_ptr + i * 8, new_fs + ((i-1) * 16 + 8), new_fs + i * 16, PERMUTATION);
    }
    return new_fs + 16 * (n_chunks - 1), transcript_ptr;
}

fn fs_receive_ef(fs, const n) -> 2 {
    new_fs, ef_ptr = fs_receive_chunks(fs, next_multiple_of(n * DIM, 8) / 8);
    for i in n * DIM..next_multiple_of(n * DIM, 8) unroll {
        assert ef_ptr[i] == 0;
    }
    return new_fs, ef_ptr;
}


fn fs_print_state(fs_state) {
    for i in 0..17 unroll {
        print(i, fs_state[i]);
    }
    return;
}

fn mul_extension_ret(a, b) inline -> 1 {
    c = malloc(DIM);
    dot_product_ee(a, b, c, 1);
    return c;
}

fn mul_extension(a, b, c) inline {
    dot_product_ee(a, b, c, 1);
    return;
}

fn add_extension_ret(a, b) inline -> 1 {
    // TODO if a and b are adjacent we can do it in one cycle using the dot_product precompile
    c = malloc(DIM);
    for i in 0..DIM unroll {
        c[i] = a[i] + b[i];
    }
    return c;
}

fn add_extension(a, b, c) inline {
    // TODO if a and b are adjacent we can do it in one cycle using the dot_product precompile
    for i in 0..DIM unroll {
        c[i] = a[i] + b[i];
    }
    return;
}

fn sub_extension(a, b, c) inline {
    // TODO if a and b are adjacent we can do it in one cycle using the dot_product precompile
    for i in 0..DIM unroll {
        c[i] = a[i] - b[i];
    }
    return;
}

fn copy_5(a, b) inline {
    dot_product_ee(a, pointer_to_one_vector, b, 1);
    return;
}

fn set_to_7_zeros(a) inline {
    zero_ptr = pointer_to_zero_vector;
    dot_product_ee(a, pointer_to_one_vector, zero_ptr, 1);
    a[5] = 0;
    a[6] = 0;
    return;
}

fn set_to_16_zeros(a) inline {
    zero_ptr = pointer_to_zero_vector;
    dot_product_ee(a, pointer_to_one_vector, zero_ptr, 1);
    dot_product_ee(a + 5, pointer_to_one_vector, zero_ptr, 1);
    dot_product_ee(a + 10, pointer_to_one_vector, zero_ptr, 1);
    a[15] = 0;
    return;
}

fn copy_8(a, b) inline {
    dot_product_ee(a, pointer_to_one_vector, b, 1);
    assert a[5] == b[5];
    assert a[6] == b[6];
    assert a[7] == b[7];
    return;
}

fn copy_16(a, b) inline {
    dot_product_ee(a, pointer_to_one_vector, b, 1);
    dot_product_ee(a + 5, pointer_to_one_vector, b + 5, 1);
    dot_product_ee(a + 10, pointer_to_one_vector, b + 10, 1);
    a[15] = b[15];
    return;
}

fn set_to_one(a) inline {
    a[0] = 1;
    for i in 1..DIM unroll { a[i] = 0; }
    return;
}


fn print_ef(a) {
    for i in 0..DIM unroll {
        print(a[i]);
    }
    return;
}

fn print_vec(a) {
    for i in 0..VECTOR_LEN unroll {
        print(a[i]);
    }
    return;
}

fn print_many(a, n) {
    for i in 0..n {
        print(a[i]);
    }
    return;
}

fn next_multiple_of_8(const a) -> 1 {
    return a + (8 - (a % 8)) % 8;
}

fn read_memory(ptr) inline -> 1  {
    mem = 0;
    return mem[ptr];
}

fn range_check(a, b) inline {
    // TODO (for now we simulate the cost)
    dummy1 = a + b;
    dummy2 = dummy1 * a;
    dummy3 = dummy2 + b;
    return;
}