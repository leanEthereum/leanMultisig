const COMPRESSION = 1;
const PERMUTATION = 0;

const V = 64;
const W = 8;
const LOG_LIFETIME = 32;

const HASH_LEN = 8;
const PUB_PARAM_LEN = 5;
const PUBKEY_LEN = HASH_LEN + PUB_PARAM_LEN;

const TWEAK_LEN_FE = 2;

// CAPACITY initial value for Poseidon24 - sponge mode
const CAP_0 = 287609684;
const CAP_1 = 1664498138;
const CAP_2 = 719484663;
const CAP_3 = 1366363664;
const CAP_4 = 1775736341;
const CAP_5 = 1392984152;
const CAP_6 = 1281304957;
const CAP_7 = 1948506587;
const CAP_8 = 660369959;

const SPONGE_N_PERMS = 35; // (5 + 2 + 64 * 8) / (24 - 9)
const SPONGE_FINAL_ZERO_PADDING = 6;
const MERKLE_DATA_PADDED_LEN = PUB_PARAM_LEN + TWEAK_LEN_FE + V * HASH_LEN + SPONGE_FINAL_ZERO_PADDING;

fn main() {
    pub_input_start = public_input_start;
    signatures_start = private_input_start();

    n_signatures = pub_input_start[0];
    tweaks = pub_input_start + 1;
    pubkeys_and_encodings = tweaks + (V * (W-1) * TWEAK_LEN_FE) + ((LOG_LIFETIME + 1) * (TWEAK_LEN_FE + 1));

    for i in 0..n_signatures {
        merkle_root = pubkeys_and_encodings + i * (PUBKEY_LEN + V);
        public_param = merkle_root + HASH_LEN;
        encoding = public_param + PUB_PARAM_LEN;
        signature = signatures_start + i * (V * HASH_LEN);
        merkle_root_recovered = xmss_recover_merkle_root(tweaks, public_param, encoding, signature);
        // assert_eq_vec(merkle_root, merkle_root_recovered);
    }
    return;
}

fn xmss_recover_merkle_root(tweaks, public_param, encoding, signature) -> 1 {
    wots_tips = signature;

    merkle_leaf_to_hash = malloc(MERKLE_DATA_PADDED_LEN);

    // This is a trick to avoid the compiler to allocate memory "on stack".
    // (Heap allocation is better here, to keep the memmory use of the different "match arms" balanced)
    hash_len = HASH_LEN;

    for chain_index in 0..V unroll {
        my_tweaks = tweaks + chain_index * (W-1) * TWEAK_LEN_FE;
        chain_end = wots_chain_hash(wots_tips + chain_index * HASH_LEN, my_tweaks, encoding[chain_index], public_param);
        assert_eq_vec(chain_end, merkle_leaf_to_hash + PUB_PARAM_LEN + TWEAK_LEN_FE + chain_index * HASH_LEN);
    }

    tree_tweaks = tweaks + V * (W-1) * TWEAK_LEN_FE;

    copy_5(public_param, merkle_leaf_to_hash);
    merkle_leaf_to_hash[5] = tree_tweaks[0];
    merkle_leaf_to_hash[6] = tree_tweaks[1];
    for i in 0..SPONGE_FINAL_ZERO_PADDING unroll {
        merkle_leaf_to_hash[MERKLE_DATA_PADDED_LEN - SPONGE_FINAL_ZERO_PADDING + i] = 0;
    }

    // sponge
    sponge_buff = malloc(24 * (2 * SPONGE_N_PERMS + 1));
    copy_5(merkle_leaf_to_hash, sponge_buff);
    copy_5(merkle_leaf_to_hash + 5, sponge_buff + 5);
    copy_5(merkle_leaf_to_hash + 10, sponge_buff + 10);
    sponge_buff[15] = CAP_0;
    sponge_buff[16] = CAP_1;
    sponge_buff[17] = CAP_2;
    sponge_buff[18] = CAP_3;
    sponge_buff[19] = CAP_4;
    sponge_buff[20] = CAP_5;
    sponge_buff[21] = CAP_6;
    sponge_buff[22] = CAP_7;
    sponge_buff[23] = CAP_8;

    for i in 0..SPONGE_N_PERMS - 1 unroll {
        curr = sponge_buff + i * 48;
        permuted = curr + 24;
        next = curr + 48;
        poseidon24(curr, curr + 16, permuted);
        copy_5(permuted + 15, next + 15);
        copy_5(permuted + 19, next + 19);
        for j in 0..15 {
            next[j] = permuted[j] + merkle_leaf_to_hash[15 * (i + 1) + j];
        }
    }
    curr = sponge_buff + (SPONGE_N_PERMS - 1) * 48;
    merkle_leaf_hashed = curr + 24;
    poseidon24(curr, curr + 16, merkle_leaf_hashed);

    print_vec(merkle_leaf_hashed);

    return 0;
}

fn wots_chain_hash(source_digest, my_tweaks, xi, public_param) -> 1 {
    n_iters = W - 1 - xi;
    buff = malloc(HASH_LEN * (n_iters + 1) * 2);
    assert_eq_vec(source_digest, buff + 7);

    // TODO unroll
    for j in 0..n_iters {
        start = buff + j * (2 * HASH_LEN);
        copy_5(public_param, start);
        start[5] = my_tweaks[(xi + j) * TWEAK_LEN_FE];
        start[6] = my_tweaks[(xi + j) * TWEAK_LEN_FE + 1];
        start[15] = 0;
        poseidon16(start, start + 8, start + (16 + 7), COMPRESSION);
    }

    return buff + n_iters * HASH_LEN * 2 + 7;
}

fn copy_5(src, dest) inline {
    dot_product_ee(src, pointer_to_one_vector, dest, 1);
    return;
}

fn assert_eq_vec(x, y) inline {
    // x and y are vectorized pointer of len 1 each
    dot_product_ee(x, pointer_to_one_vector, y, 1);
    dot_product_ee(x + 3, pointer_to_one_vector, y + 3, 1);
    return;
}

fn print_vec(vec) {
    for i in 0..HASH_LEN unroll {
        print(vec[i]);
    }
    return;
}