const COMPRESSION = 1;
const PERMUTATION = 0;

const V = 64;
const W = 8;
const LOG_LIFETIME = 32;

const HASH_LEN = 8;
const PUB_PARAM_LEN = 5;
const PUBKEY_LEN = HASH_LEN + PUB_PARAM_LEN;

const TWEAK_LEN_FE = 2;

fn main() {
    pub_input_start = public_input_start;
    signatures_start = private_input_start();

    n_signatures = pub_input_start[0];
    tweaks = pub_input_start + 1;
    pubkeys_and_encodings = tweaks + (V * (W-1) * TWEAK_LEN_FE) + ((LOG_LIFETIME + 1) * (TWEAK_LEN_FE + 1));

    for i in 0..n_signatures {
        merkle_root = pubkeys_and_encodings + i * (PUBKEY_LEN + V);
        public_param = merkle_root + HASH_LEN;
        encoding = public_param + PUB_PARAM_LEN;
        signature = signatures_start + i * (V * HASH_LEN);
        merkle_root_recovered = xmss_recover_merkle_root(tweaks, public_param, encoding, signature);
        // assert_eq_vec(merkle_root, merkle_root_recovered);
    }
    return;
}

fn xmss_recover_merkle_root(tweaks, public_param, encoding, signature) -> 1 {
    wots_tips = signature;

    wots_public_key = malloc(V * HASH_LEN);

    // This is a trick to avoid the compiler to allocate memory "on stack".
    // (Heap allocation is better here, to keep the memmory use of the different "match arms" balanced)
    hash_len = HASH_LEN;

    for chain_index in 0..V unroll {
        my_tweaks = tweaks + chain_index * (W-1) * TWEAK_LEN_FE;
        chain_end = wots_chain_hash(wots_tips + chain_index * HASH_LEN, my_tweaks, encoding[chain_index], public_param);
        assert_eq_vec(chain_end, wots_public_key + chain_index * HASH_LEN);
        print(chain_index);
        print_vec(chain_end);
    }

    return 0;
}

fn wots_chain_hash(source_digest, my_tweaks, xi, public_param) -> 1 {
    buff = malloc(HASH_LEN * (W - xi));
    assert_eq_vec(source_digest, buff);
    print(xi);
    // TODO unroll
    for j in xi..W - 1 {
        to_hash_left = malloc(HASH_LEN);
        copy_5(public_param, to_hash_left);
        to_hash_left[5] = my_tweaks[j * TWEAK_LEN_FE];
        to_hash_left[6] = my_tweaks[j * TWEAK_LEN_FE + 1];
        poseidon16(to_hash_left, buff + j * HASH_LEN, buff + (j+1) * HASH_LEN, COMPRESSION);
    }

    return buff + (W - xi - 1) * HASH_LEN;
}

fn copy_5(src, dest) inline {
    dot_product_ee(src, pointer_to_one_vector, dest, 1);
    return;
}

fn assert_eq_vec(x, y) inline {
    // x and y are vectorized pointer of len 1 each
    dot_product_ee(x, pointer_to_one_vector, y, 1);
    dot_product_ee(x + 3, pointer_to_one_vector, y + 3, 1);
    return;
}

fn print_vec(vec) {
    for i in 0..HASH_LEN unroll {
        print(vec[i]);
    }
    return;
}