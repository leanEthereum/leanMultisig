const COMPRESSION = 1;
const PERMUTATION = 0;

const V = 64;
const W = 8;
const MAX_LOG_LIFETIME = 32;

const HASH_LEN = 8;
const PUB_PARAM_LEN = 5;
const PUBKEY_LEN = HASH_LEN + PUB_PARAM_LEN;

fn main() {
    public_input_start_ = public_input_start;
    signatures_start = private_input_start();

    n_signatures = public_input_start_[0];
    epoch = public_input_start_[1];
    all_public_keys = public_input_start_ + 2;
    all_log_lifetimes = all_public_keys + n_signatures * HASH_LEN;
    all_merkle_indexes = all_log_lifetimes + n_signatures;
    sig_sizes = all_merkle_indexes + n_signatures * MAX_LOG_LIFETIME;


    for i in 0..n_signatures {
        xmss_public_key = all_public_keys + i * HASH_LEN;
        signature = signatures_start + sig_sizes[i];
        log_lifetime = all_log_lifetimes[i];
        merkle_index = all_merkle_indexes + i * MAX_LOG_LIFETIME;
        xmss_public_key_recovered = xmss_recover_pub_key(message_hash, signature, log_lifetime, merkle_index);
        assert_eq_vec(xmss_public_key, xmss_public_key_recovered);
    }
    return;
}

fn xmss_recover_pub_key(message_hash, signature, log_lifetime, merkle_index) -> 1 {
    // signature: randomness | chain_tips
    // return the hashed xmss public key
    randomness = signature;
    chain_tips = signature + HASH_LEN;
    merkle_path = chain_tips + V * HASH_LEN; 

    // 1) We encode message_hash + randomness into the d-th layer of the hypercube

    compressed = malloc(HASH_LEN);
    poseidon16(message_hash, randomness, compressed, COMPRESSION);
    compressed_vals = malloc(6);
    dot_product_ee(compressed, pointer_to_one_vector, compressed_vals, 1);
    compressed_vals[5] = compressed[5];

    encoding = malloc(12 * 6);
    remaining = malloc(6);

    decompose_custom(encoding, remaining, compressed_vals[0], compressed_vals[1], compressed_vals[2], compressed_vals[3], compressed_vals[4], compressed_vals[5]);

    // check that the decomposition is correct
    for i in 0..6 unroll {
        for j in 0..12 unroll {
            // TODO Implem range check (https://github.com/leanEthereum/leanMultisig/issues/52)
            // For now we use dummy instructions to replicate exactly the cost

            // assert encoding[i * 12 + j] < 4;
            dummy_0 = 88888888;
            assert dummy_0 == 88888888;
            assert dummy_0 == 88888888;
            assert dummy_0 == 88888888;
        }

        // assert remaining[i] < 2^7 - 1;
        dummy_1 = 88888888;
        dummy_2 = 88888888;
        dummy_3 = 88888888;
        assert dummy_1 == 88888888;
        assert dummy_2 == 88888888;
        assert dummy_3 == 88888888;

        partial_sums = malloc(13);
        partial_sums[0] = remaining[i] * 2**24;
        for j in 1..13 unroll {
            partial_sums[j] = partial_sums[j - 1] + encoding[i * 12 + (j-1)] * 4**(j-1);
        }
        assert partial_sums[12] == compressed_vals[i];
    }
    
    // we need to check the target sum
    sums = malloc(V);
    sums[0] = encoding[0];
    for i in 1..V unroll {
        sums[i] = sums[i - 1] + encoding[i];
    }
    assert sums[V - 1] == TARGET_SUM;

    public_key = malloc(V * HASH_LEN);

    // This is a trick to avoid the compiler to allocate memory "on stack".
    // (Heap allocation is better here, to keep the memmory use of the different "match arms" balanced)
    HASH_LEN = HASH_LEN;

    for i in 0..V unroll {
        match encoding[i] {
            0 => {
                var_1 = chain_tips + i * HASH_LEN;
                var_2 = public_key + i * HASH_LEN;
                var_3 = malloc(HASH_LEN);
                var_4 = malloc(HASH_LEN);
                poseidon16(var_1, pointer_to_zero_vector, var_3, COMPRESSION);
                poseidon16(var_3, pointer_to_zero_vector, var_4, COMPRESSION);
                poseidon16(var_4, pointer_to_zero_vector, var_2, COMPRESSION);
            }
            1 => {
                var_3 = malloc(HASH_LEN);
                var_1 = chain_tips + i * HASH_LEN;
                var_2 = public_key + i * HASH_LEN;
                poseidon16(var_1, pointer_to_zero_vector, var_3, COMPRESSION);
                poseidon16(var_3, pointer_to_zero_vector, var_2, COMPRESSION);
            }
            2 => {
                var_1 = chain_tips + i * HASH_LEN;
                var_2 = public_key + i * HASH_LEN;
                poseidon16(var_1, pointer_to_zero_vector, var_2, COMPRESSION);
            }
            3 => {
                var_1 = chain_tips + (i * HASH_LEN);
                var_2 = public_key + (i * HASH_LEN);
                var_3 = var_1 + 3;
                var_4 = var_2 + 3;
                dot_product_ee(var_1, pointer_to_one_vector, var_2, 1);
                dot_product_ee(var_3, pointer_to_one_vector, var_4, 1);
            }
        }
    }

    wots_pubkey_hashed = slice_hash(pointer_to_zero_vector, public_key, V_HALF);
    
    var merkle_root;
    match log_lifetime {
        0 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 0); }
        1 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 1); }
        2 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 2); }
        3 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 3); }
        4 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 4); }
        5 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 5); }
        6 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 6); }
        7 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 7); }
        8 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 8); }
        9 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 9); }
        10 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 10); }
        11 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 11); }
        12 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 12); }
        13 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 13); }
        14 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 14); }
        15 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 15); }
        16 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 16); }
        17 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 17); }
        18 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 18); }
        19 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 19); }
        20 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 20); }
        21 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 21); }
        22 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 22); }
        23 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 23); }
        24 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 24); }
        25 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 25); }
        26 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 26); }
        27 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 27); }
        28 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 28); }
        29 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 29); }
        30 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 30); }
        31 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 31); }
        32 => { merkle_root = merkle_verify(wots_pubkey_hashed, merkle_path, merkle_index, 32); }
    }           

    return merkle_root;
}


fn merkle_verify(leaf_digest, merkle_path, leaf_position_bits, const height) -> 1 {
    states = malloc(height * HASH_LEN);
    
    // First merkle round
    match leaf_position_bits[0] {
        0 => { poseidon16(leaf_digest, merkle_path, states, COMPRESSION); }
        1 => { poseidon16(merkle_path, leaf_digest, states, COMPRESSION); }
    }

    // Remaining merkle rounds
    state_indexes = malloc(height);
    state_indexes[0] = states;
    for j in 1..height unroll {
        state_indexes[j] = state_indexes[j-1] + HASH_LEN;
        // Warning: this works only if leaf_position_bits[i] is known to be boolean:
        match leaf_position_bits[j] {
            0 => { poseidon16(state_indexes[j-1], merkle_path + j * HASH_LEN, state_indexes[j], COMPRESSION); }
            1 => { poseidon16(merkle_path + j * HASH_LEN, state_indexes[j-1], state_indexes[j], COMPRESSION); }
        }
    }
    return state_indexes[height - 1];
}

fn slice_hash(seed, data, const half_len) -> 1 {
    states = malloc(half_len * 2 * HASH_LEN);
    poseidon16(pointer_to_zero_vector, data, states, COMPRESSION);
    state_indexes = malloc(half_len * 2);
    state_indexes[0] = states;
    for j in 1..(half_len * 2) unroll {
        state_indexes[j] = state_indexes[j-1] + HASH_LEN;
        poseidon16(state_indexes[j-1], data + j * HASH_LEN, state_indexes[j], COMPRESSION);
    }
    return state_indexes[half_len * 2 - 1];
}

fn assert_eq_vec(x, y) inline {
    // x and y are vectorized pointer of len 1 each
    dot_product_ee(x, pointer_to_one_vector, y, 1);
    dot_product_ee(x + 3, pointer_to_one_vector, y + 3, 1);
    return;
}
