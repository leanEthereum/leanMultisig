const COMPRESSION = 1;

const V = V_PLACEHOLDER;
const W = W_PLACEHOLDER;
const LOG_LIFETIME = LOG_LIFETIME_PLACEHOLDER;
const HASH_LEN = 8;
const PUB_PARAM_LEN = 5;
const PUBKEY_LEN = HASH_LEN + PUB_PARAM_LEN;
const TWEAK_LEN_FE = 2;

// CAPACITY initial value for Poseidon24 - sponge mode
const CAP_0 = CAP_0_PLACEHOLDER;
const CAP_1 = CAP_1_PLACEHOLDER;
const CAP_2 = CAP_2_PLACEHOLDER;
const CAP_3 = CAP_3_PLACEHOLDER;
const CAP_4 = CAP_4_PLACEHOLDER;
const CAP_5 = CAP_5_PLACEHOLDER;
const CAP_6 = CAP_6_PLACEHOLDER;
const CAP_7 = CAP_7_PLACEHOLDER;
const CAP_8 = CAP_8_PLACEHOLDER;

const SPONGE_N_PERMS = SPONGE_N_PERMS_PLACEHOLDER;
const SPONGE_FINAL_ZERO_PADDING = SPONGE_FINAL_ZERO_PADDING_PLACEHOLDER;
const MERKLE_DATA_PADDED_LEN = PUB_PARAM_LEN + TWEAK_LEN_FE + V * HASH_LEN + SPONGE_FINAL_ZERO_PADDING;

fn main() {
    pub_input_start = public_input_start;
    signatures_start = private_input_start();

    n_signatures = pub_input_start[0];
    tweaks = pub_input_start + 1;
    pubkeys_and_encodings = tweaks + (V * (W-1) * TWEAK_LEN_FE) + ((LOG_LIFETIME + 1) * (TWEAK_LEN_FE + 1));

    for i in 0..n_signatures {
        merkle_root = pubkeys_and_encodings + i * (PUBKEY_LEN + V);
        public_param = merkle_root + HASH_LEN;
        encoding = public_param + PUB_PARAM_LEN;
        wots_tips = signatures_start + i * ((V + LOG_LIFETIME) * HASH_LEN);
        merkle_path = wots_tips + V * HASH_LEN;
        merkle_root_recovered = xmss_recover_merkle_root(tweaks, public_param, encoding, merkle_path, wots_tips);
        copy_8(merkle_root, merkle_root_recovered);
    }
    return;
}

fn xmss_recover_merkle_root(tweaks, public_param, encoding, merkle_path, wots_tips) -> 1 {
    merkle_leaf_to_hash = malloc(MERKLE_DATA_PADDED_LEN);

    for chain_index in 0..V unroll {
        my_tweaks = tweaks + chain_index * (W-1) * TWEAK_LEN_FE;
        chain_end = wots_chain_hash(wots_tips + chain_index * HASH_LEN, my_tweaks, encoding[chain_index], public_param);
        copy_8(chain_end, merkle_leaf_to_hash + PUB_PARAM_LEN + TWEAK_LEN_FE + chain_index * HASH_LEN);
    }

    tree_tweaks = tweaks + V * (W-1) * TWEAK_LEN_FE;

    copy_5(public_param, merkle_leaf_to_hash);
    merkle_leaf_to_hash[5] = tree_tweaks[0];
    merkle_leaf_to_hash[6] = tree_tweaks[1];
    for i in 0..SPONGE_FINAL_ZERO_PADDING unroll {
        merkle_leaf_to_hash[MERKLE_DATA_PADDED_LEN - SPONGE_FINAL_ZERO_PADDING + i] = 0;
    }

    // sponge
    sponge_buff = malloc(24 * (2 * SPONGE_N_PERMS + 1));
    copy_5(merkle_leaf_to_hash, sponge_buff);
    copy_5(merkle_leaf_to_hash + 5, sponge_buff + 5);
    copy_5(merkle_leaf_to_hash + 10, sponge_buff + 10);
    sponge_buff[15] = CAP_0;
    sponge_buff[16] = CAP_1;
    sponge_buff[17] = CAP_2;
    sponge_buff[18] = CAP_3;
    sponge_buff[19] = CAP_4;
    sponge_buff[20] = CAP_5;
    sponge_buff[21] = CAP_6;
    sponge_buff[22] = CAP_7;
    sponge_buff[23] = CAP_8;

    for i in 0..SPONGE_N_PERMS - 1 unroll {
        curr = sponge_buff + i * 48;
        permuted = curr + 24;
        next = curr + 48;
        poseidon24(curr, curr + 16, permuted);
        copy_5(permuted + 15, next + 15);
        copy_5(permuted + 19, next + 19);
        for j in 0..15 {
            next[j] = permuted[j] + merkle_leaf_to_hash[15 * (i + 1) + j];
        }
    }
    curr = sponge_buff + (SPONGE_N_PERMS - 1) * 48;
    merkle_leaf_hashed = curr + 24;
    poseidon24(curr, curr + 16, merkle_leaf_hashed);

    merkle_nodes = malloc(HASH_LEN * (LOG_LIFETIME + 1));
    copy_8(merkle_leaf_hashed, merkle_nodes);

    for i in 0..LOG_LIFETIME unroll {
        inputs = malloc(24);
        outputs = malloc(24);
        copy_5(public_param, inputs);
        inputs[5] = tree_tweaks[3 * (i+1)];
        inputs[6] = tree_tweaks[3 * (i+1) + 1];
        inputs[23] = 0;
        current_pos = tree_tweaks[3*i + 2];
        match current_pos {
            0 => {
                copy_8(merkle_nodes + i * HASH_LEN, inputs + 15);
                copy_8(merkle_path + i * HASH_LEN, inputs + 7);
            }
            1 => {
                copy_8(merkle_nodes + i * HASH_LEN, inputs + 7);
                copy_8(merkle_path + i * HASH_LEN, inputs + 15);
            }
        }
        poseidon24(inputs, inputs + 16, outputs);
        for j in 0..HASH_LEN unroll {
            merkle_nodes[(i+1) * HASH_LEN + j] = outputs[j] + inputs[j];
        }
    }
    return merkle_nodes + HASH_LEN * LOG_LIFETIME;
}

fn wots_chain_hash(source_digest, my_tweaks, xi, public_param) -> 1 {
    n_iters = W - 1 - xi;
    buff = malloc(HASH_LEN * (n_iters + 1) * 2);
    copy_8(source_digest, buff + 7);

    // TODO unroll
    for j in 0..n_iters {
        start = buff + j * (2 * HASH_LEN);
        copy_5(public_param, start);
        start[5] = my_tweaks[(xi + j) * TWEAK_LEN_FE];
        start[6] = my_tweaks[(xi + j) * TWEAK_LEN_FE + 1];
        start[15] = 0;
        poseidon16(start, start + 8, start + (16 + 7), COMPRESSION);
    }

    return buff + n_iters * HASH_LEN * 2 + 7;
}

fn copy_5(src, dest) inline {
    dot_product_ee(src, pointer_to_one_vector, dest, 1);
    return;
}

fn copy_8(x, y) inline {
    dot_product_ee(x, pointer_to_one_vector, y, 1);
    dot_product_ee(x + 3, pointer_to_one_vector, y + 3, 1);
    return;
}
