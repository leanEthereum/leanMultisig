
// 1 OOD QUERY PER ROUND -> TODO
// 0 GRINDING IN SUMCHECK -> TODO

const COMPRESSION = 1;
const PERMUTATION = 0;

const F_BITS = 31; // koala-bear = 31 bits
const DIM = 5; // extension degree

const N_VARS = N_VARS_PLACEHOLDER;
const LOG_INV_RATE = LOG_INV_RATE_PLACEHOLDER; 
const N_ROUNDS = 3; // TODO make it a parameter

const PADDING_FOR_INITIAL_MERKLE_LEAVES = PADDING_FOR_INITIAL_MERKLE_LEAVES_PLACEHOLDER;

const FOLDING_FACTOR_0 = FOLDING_FACTOR_0_PLACEHOLDER;
const FOLDING_FACTOR_1 = FOLDING_FACTOR_1_PLACEHOLDER;
const FOLDING_FACTOR_2 = FOLDING_FACTOR_2_PLACEHOLDER;
const FOLDING_FACTOR_3 = FOLDING_FACTOR_3_PLACEHOLDER;

const FINAL_VARS = N_VARS - (FOLDING_FACTOR_0 + FOLDING_FACTOR_1 + FOLDING_FACTOR_2 + FOLDING_FACTOR_3);

const RS_REDUCTION_FACTOR_0 = RS_REDUCTION_FACTOR_0_PLACEHOLDER;
const RS_REDUCTION_FACTOR_1 = 1;
const RS_REDUCTION_FACTOR_2 = 1;
const RS_REDUCTION_FACTOR_3 = 1;

const NUM_QUERIES_0 = NUM_QUERIES_0_PLACEHOLDER;
const NUM_QUERIES_1 = NUM_QUERIES_1_PLACEHOLDER;
const NUM_QUERIES_2 = NUM_QUERIES_2_PLACEHOLDER;
const NUM_QUERIES_3 = NUM_QUERIES_3_PLACEHOLDER;

const GRINDING_BITS_0 = GRINDING_BITS_0_PLACEHOLDER;
const GRINDING_BITS_1 = GRINDING_BITS_1_PLACEHOLDER;
const GRINDING_BITS_2 = GRINDING_BITS_2_PLACEHOLDER;
const GRINDING_BITS_3 = GRINDING_BITS_3_PLACEHOLDER;

const MERKLE_HEIGHT_0 = N_VARS + LOG_INV_RATE - FOLDING_FACTOR_0;
const MERKLE_HEIGHT_1 = N_VARS + LOG_INV_RATE - FOLDING_FACTOR_1 - RS_REDUCTION_FACTOR_0;
const MERKLE_HEIGHT_2 = MERKLE_HEIGHT_1 - RS_REDUCTION_FACTOR_1;
const MERKLE_HEIGHT_3 = MERKLE_HEIGHT_2 - RS_REDUCTION_FACTOR_2;

const TWO_ADICITY = 24;
const ROOT = 1791270792; // of order 2^TWO_ADICITY

const N_RECURSIONS = N_RECURSIONS_PLACEHOLDER;

fn main() {
    for _ in 0..N_RECURSIONS {
        whir_recursion();
    }
    return;
}

fn whir_recursion() {
    transcript_start = public_input_start / 8;
    fs_state = fs_new(transcript_start);

    fs_state_0, root_0, ood_point_0, ood_eval_0 = parse_commitment(fs_state);

    // In the future point / eval will come from the PIOP
    point_vector_len = next_multiple_of_8(N_VARS * DIM);
    fs_state_1, pcs_point_vec = fs_hint(fs_state_0, point_vector_len / 8);
    pcs_point = pcs_point_vec * 8;
    fs_state_2, pcs_eval_vec = fs_hint(fs_state_1, 1);
    pcs_eval = pcs_eval_vec * 8;

    fs_state_3, _ = fs_hint(fs_state_2, PADDING_FOR_INITIAL_MERKLE_LEAVES);
    fs_state_4, combination_randomness_gen_0 = fs_sample_ef(fs_state_3);

    claimed_sum_side = mul_extension_ret(combination_randomness_gen_0, pcs_eval);
    claimed_sum_0 = add_extension_ret(ood_eval_0, claimed_sum_side);
    domain_size_0 = N_VARS + LOG_INV_RATE;
    fs_state_5, folding_randomness_1, ood_point_1, root_1, circle_values_1, combination_randomness_powers_1, claimed_sum_1 = 
        whir_round(fs_state_4, root_0, FOLDING_FACTOR_0, 2**FOLDING_FACTOR_0, 1, NUM_QUERIES_0, domain_size_0, claimed_sum_0, GRINDING_BITS_0);

    domain_size_1 = domain_size_0 - RS_REDUCTION_FACTOR_0;
    fs_state_6, folding_randomness_2, ood_point_2, root_2, circle_values_2, combination_randomness_powers_2, claimed_sum_2 = 
        whir_round(fs_state_5, root_1, FOLDING_FACTOR_1, 2**FOLDING_FACTOR_1, 0, NUM_QUERIES_1, domain_size_1, claimed_sum_1, GRINDING_BITS_1);

    domain_size_2 = domain_size_1 - RS_REDUCTION_FACTOR_1;
    fs_state_7, folding_randomness_3, ood_point_3, root_3, circle_values_3, combination_randomness_powers_3, claimed_sum_3 = 
        whir_round(fs_state_6, root_2, FOLDING_FACTOR_2, 2**FOLDING_FACTOR_2, 0, NUM_QUERIES_2, domain_size_2, claimed_sum_2, GRINDING_BITS_2);

    domain_size_3 = domain_size_2 - RS_REDUCTION_FACTOR_2;
    fs_state_8, folding_randomness_4, final_claimed_sum = sumcheck(fs_state_7, FOLDING_FACTOR_3, claimed_sum_3);
    
    fs_state_9, final_coeffcients_unpacked = fs_receive(fs_state_8, 2**FINAL_VARS);
    final_coeffcients = malloc(2**FINAL_VARS * DIM);
    for i in 0..2**FINAL_VARS {
        assert_eq_extension((final_coeffcients_unpacked + i) * 8, final_coeffcients + i*DIM);
    }

    fs_state_10, final_circle_values, final_folds =
        sample_stir_indexes_and_fold(fs_state_9, NUM_QUERIES_3, 0, FOLDING_FACTOR_3, 2**FOLDING_FACTOR_3, domain_size_3, root_3, folding_randomness_4, GRINDING_BITS_3);
    
    for i in 0..NUM_QUERIES_3 {
        powers_of_2_rev = expand_from_univariate_const(final_circle_values[i], FINAL_VARS);
        poly_eq = poly_eq_base(powers_of_2_rev, FINAL_VARS);
        final_pol_evaluated_on_circle = malloc(DIM);
        dot_product_be(poly_eq, final_coeffcients, final_pol_evaluated_on_circle, 2**FINAL_VARS); 
        assert_eq_extension(final_pol_evaluated_on_circle, final_folds + i*DIM);
    }

    fs_state_11, folding_randomness_5, end_sum = sumcheck(fs_state_10, FINAL_VARS, final_claimed_sum);

    folding_randomness_global = malloc(N_VARS * DIM);

    ffs = malloc(N_ROUNDS + 2);
    ffs[0] = FOLDING_FACTOR_0; ffs[1] = FOLDING_FACTOR_1; ffs[2] = FOLDING_FACTOR_2; ffs[3] = FOLDING_FACTOR_3; ffs[4] = FINAL_VARS;
    frs = malloc(N_ROUNDS + 2);
    frs[0] = folding_randomness_1; frs[1] = folding_randomness_2; frs[2] = folding_randomness_3; frs[3] = folding_randomness_4; frs[4] = folding_randomness_5;
    ffs_sums = malloc(N_ROUNDS + 3);
    ffs_sums[0] = 0;
    for i in 0..N_ROUNDS + 2 {
        ffs_sums[i + 1] = ffs_sums[i] + ffs[i];
    }
    for i in 0..N_ROUNDS + 2 {
        start = folding_randomness_global + ffs_sums[i] * DIM;
        for j in 0..ffs[i] {
            assert_eq_extension(frs[i] + j*DIM, start + j*DIM);
        }
    }

    ood_0_expanded_from_univariate = expand_from_univariate(ood_point_0, N_VARS);
    s0 = eq_mle_extension(ood_0_expanded_from_univariate, folding_randomness_global, N_VARS);
    s1 = eq_mle_extension(pcs_point, folding_randomness_global, N_VARS);
    s3 = mul_extension_ret(s1, combination_randomness_gen_0);
    s4 = add_extension_ret(s0, s3);

    weight_sums = malloc(N_ROUNDS + 1);
    weight_sums[0] = s4;

    ood_points = malloc(N_ROUNDS + 1); ood_points[0] = ood_point_0; ood_points[1] = ood_point_1; ood_points[2] = ood_point_2; ood_points[3] = ood_point_3;
    num_queries = malloc(N_ROUNDS + 1); num_queries[0] = NUM_QUERIES_0; num_queries[1] = NUM_QUERIES_1; num_queries[2] = NUM_QUERIES_2; num_queries[3] = NUM_QUERIES_3;
    circle_values = malloc(N_ROUNDS + 1); circle_values[0] = circle_values_1; circle_values[1] = circle_values_2; circle_values[2] = circle_values_3; circle_values[3] = final_circle_values;
    combination_randomness_powers = malloc(N_ROUNDS); combination_randomness_powers[0] = combination_randomness_powers_1; combination_randomness_powers[1] = combination_randomness_powers_2; combination_randomness_powers[2] = combination_randomness_powers_3;

    for i in 0..N_ROUNDS {
        ood_expanded_from_univariate = expand_from_univariate(ood_points[i + 1], N_VARS - ffs_sums[i+1]);
        s5 = eq_mle_extension(ood_expanded_from_univariate, folding_randomness_global + ffs_sums[i+1]*DIM, N_VARS - ffs_sums[i+1]);
        s6s = malloc((num_queries[i] + 1) * DIM);
        assert_eq_extension(s5, s6s);
        circle_value_i = circle_values[i];
        for j in 0..num_queries[i] {
            expanded_from_univariate = expand_from_univariate_dynamic(circle_value_i[j], N_VARS - ffs_sums[i+1]);
            temp = eq_mle_extension_base_dynamic(expanded_from_univariate, folding_randomness_global + ffs_sums[i+1]*DIM, N_VARS - ffs_sums[i+1]);
            assert_eq_extension(temp, s6s + (j + 1) * DIM);
        }
        s7 = malloc(DIM);
        dot_product_ee_dynamic(s6s, combination_randomness_powers[i], s7, num_queries[i] + 1);
        wsum = add_extension_ret(weight_sums[i], s7);
        weight_sums[i+1] = wsum;
    }
    evaluation_of_weights = weight_sums[N_ROUNDS]; // not good
    poly_eq_final = poly_eq_extension(folding_randomness_5, FINAL_VARS, 2**FINAL_VARS);
    final_value = malloc(DIM);
    dot_product_ee(poly_eq_final, final_coeffcients, final_value, 2**FINAL_VARS);
    evaluation_of_weights_times_final_value = mul_extension_ret(evaluation_of_weights, final_value);
    assert_eq_extension(evaluation_of_weights_times_final_value, end_sum);
    return;
}

fn eq_mle_extension(a, b, n) -> 1 {

    buff = malloc(n*DIM);

    for i in 0..n {
        shift = i * DIM;
        ai = a + shift;
        bi = b + shift;
        buffi = buff + shift;
        ab = mul_extension_ret(ai, bi);
        buffi[0] = 1 + 2 * ab[0] - ai[0] - bi[0];
        for j in 1..DIM unroll {
            buffi[j] = 2 * ab[j] - ai[j] - bi[j];
        }
    }

    prods = malloc(n*DIM);
    assert_eq_extension(buff, prods);
    for i in 0..n - 1 {
        mul_extension(prods + i*DIM, buff + (i + 1)*DIM, prods + (i + 1)*DIM);
    }

    return prods + (n - 1) * DIM;
}

fn eq_mle_extension_base_dynamic(a, b, n) -> 1 {
    res = malloc(DIM);
    match n {
        0 => {  } // unreachable
        1 => { eq_poly_base_ext(a, b, res, 1); }
        2 => { eq_poly_base_ext(a, b, res, 2); }
        3 => { eq_poly_base_ext(a, b, res, 3); }
        4 => { eq_poly_base_ext(a, b, res, 4); }
        5 => { eq_poly_base_ext(a, b, res, 5); }
        6 => { eq_poly_base_ext(a, b, res, 6); }
        7 => { eq_poly_base_ext(a, b, res, 7); }
        8 => { eq_poly_base_ext(a, b, res, 8); }
        9 => { eq_poly_base_ext(a, b, res, 9); }
        10 => { eq_poly_base_ext(a, b, res, 10); }
        11 => { eq_poly_base_ext(a, b, res, 11); }
        12 => { eq_poly_base_ext(a, b, res, 12); }
        13 => { eq_poly_base_ext(a, b, res, 13); }
        14 => { eq_poly_base_ext(a, b, res, 14); }
        15 => { eq_poly_base_ext(a, b, res, 15); }
        16 => { eq_poly_base_ext(a, b, res, 16); }
        17 => { eq_poly_base_ext(a, b, res, 17); }
        18 => { eq_poly_base_ext(a, b, res, 18); }
        19 => { eq_poly_base_ext(a, b, res, 19); }
        20 => { eq_poly_base_ext(a, b, res, 20); }
        21 => { eq_poly_base_ext(a, b, res, 21); }
        22 => { eq_poly_base_ext(a, b, res, 22); }
    }
    return res;
}

fn expand_from_univariate_dynamic(alpha, n) -> 1 {
    match n {
        0 => {  } // unreachable
        1 => { res = expand_from_univariate_const(alpha, 1); }
        2 => { res = expand_from_univariate_const(alpha, 2); }
        3 => { res = expand_from_univariate_const(alpha, 3); }
        4 => { res = expand_from_univariate_const(alpha, 4); }
        5 => { res = expand_from_univariate_const(alpha, 5); }
        6 => { res = expand_from_univariate_const(alpha, 6); }
        7 => { res = expand_from_univariate_const(alpha, 7); }
        8 => { res = expand_from_univariate_const(alpha, 8); }
        9 => { res = expand_from_univariate_const(alpha, 9); }
        10 => { res = expand_from_univariate_const(alpha, 10); }
        11 => { res = expand_from_univariate_const(alpha, 11); }
        12 => { res = expand_from_univariate_const(alpha, 12); }
        13 => { res = expand_from_univariate_const(alpha, 13); }
        14 => { res = expand_from_univariate_const(alpha, 14); }
        15 => { res = expand_from_univariate_const(alpha, 15); }
        16 => { res = expand_from_univariate_const(alpha, 16); }
        17 => { res = expand_from_univariate_const(alpha, 17); }
        18 => { res = expand_from_univariate_const(alpha, 18); }
        19 => { res = expand_from_univariate_const(alpha, 19); }
        20 => { res = expand_from_univariate_const(alpha, 20); }
        21 => { res = expand_from_univariate_const(alpha, 21); }
        22 => { res = expand_from_univariate_const(alpha, 22); }
    }
    return res;
}

fn expand_from_univariate_const(alpha, const n) -> 1 {
    // "expand_from_univariate"
    // alpha: F

    res = malloc(n);
    res[0] = alpha;
    for i in 0..n-1 unroll {
        res[i+1] = res[i] * res[i];
    }
    return res;
}

fn expand_from_univariate(alpha, n) -> 1 {
    res = malloc(n*DIM);
    assert_eq_extension(alpha, res);
    for i in 0..n-1 {
        mul_extension(res + i*DIM, res + i*DIM, res + (i + 1)*DIM);
    }
    return res;
}

fn sumcheck(fs_state, n_steps, claimed_sum) -> 3 {

    fs_states_a = malloc(n_steps + 1);
    fs_states_a[0] = fs_state;

    claimed_sums = malloc(n_steps + 1);
    claimed_sums[0] = claimed_sum;

    folding_randomness = malloc(n_steps * DIM);

    for sc_round in 0..n_steps {
        fs_state_5, poly = fs_receive_ef(fs_states_a[sc_round], 3);
        sum_over_boolean_hypercube = degree_two_polynomial_sum_at_0_and_1(poly);
        assert_eq_extension(sum_over_boolean_hypercube, claimed_sums[sc_round]);
        fs_state_6, rand = fs_sample_ef(fs_state_5);
        fs_states_a[sc_round + 1] = fs_state_6;
        new_claimed_sum = degree_two_polynomial_eval(poly, rand);
        claimed_sums[sc_round + 1] = new_claimed_sum;
        assert_eq_extension(rand, folding_randomness + sc_round * DIM);
    }

    new_state = fs_states_a[n_steps];
    new_claimed_sum = claimed_sums[n_steps];

    return new_state, folding_randomness, new_claimed_sum;
}

fn sample_stir_indexes_and_fold(fs_state, num_queries, merkle_leaves_in_basefield, folding_factor, two_pow_folding_factor, domain_size, prev_root, folding_randomness, grinding_bits) -> 3 {

    folded_domain_size = domain_size - folding_factor;

    fs_state_8 = fs_grinding(fs_state, grinding_bits);
    fs_state_9, stir_challenges_indexes = sample_bits_dynamic(fs_state_8, num_queries, folded_domain_size);

    answers = malloc(num_queries); // a vector of vectorized pointers, each pointing to `two_pow_folding_factor` field elements (base if first rounds, extension otherwise)
    fs_states_b = malloc(num_queries + 1);
    fs_states_b[0] = fs_state_9;
    
    // the number of chunk of 8 field elements per merkle leaf opened
    if merkle_leaves_in_basefield == 1 {
        n_chuncks_per_answer = two_pow_folding_factor / 8; // "/ 8" because initial merkle leaves are in the basefield
    } else {
        n_chuncks_per_answer = two_pow_folding_factor * DIM / 8;
    }

    for i in 0..num_queries {
        new_fs_state, answer = fs_hint(fs_states_b[i], n_chuncks_per_answer); 
        fs_states_b[i + 1] = new_fs_state;
        answers[i] = answer;
    }
    fs_state_10 = fs_states_b[num_queries];

    leaf_hashes = malloc(num_queries); // a vector of vectorized pointers, each pointing to 1 chunk of 8 field elements
    batch_hash_slice_dynamic(num_queries, answers, leaf_hashes, n_chuncks_per_answer);

    // Merkle verification
    merkle_verif_batch_dynamic(num_queries, leaf_hashes, stir_challenges_indexes + num_queries, prev_root, folded_domain_size);

    folds = malloc(num_queries * DIM);

    poly_eq = poly_eq_extension(folding_randomness, folding_factor, two_pow_folding_factor);

    if merkle_leaves_in_basefield == 1 {
        for i in 0..num_queries {
            dot_product_be(answers[i] * 8, poly_eq, folds + i*DIM, 2**FOLDING_FACTOR_0);
        }
    } else {
        for i in 0..num_queries {
            dot_product_ee_dynamic(answers[i] * 8, poly_eq, folds + i*DIM, two_pow_folding_factor);
        }
    }

    circle_values = malloc(num_queries); // ROOT^each_stir_index
    for i in 0..num_queries {
        stir_index_bits = stir_challenges_indexes[i];
        circle_value = unit_root_pow_dynamic(folded_domain_size, stir_index_bits);
        circle_values[i] = circle_value;
    }

    return fs_state_10, circle_values, folds;
}

fn batch_hash_slice_dynamic(num_queries, all_data_to_hash, all_resulting_hashes, len) {
    if len == DIM * 2 {
        batch_hash_slice_const(num_queries, all_data_to_hash, all_resulting_hashes, DIM);
        return;
    }
    if len == 16 {
        batch_hash_slice_const(num_queries, all_data_to_hash, all_resulting_hashes, 8);
        return;
    }
    TODO_batch_hash_slice_dynamic = len;
    print(77777123);
    print(len);
    panic();
}

fn batch_hash_slice_const(num_queries, all_data_to_hash, all_resulting_hashes, const half_len) {
    for i in 0..num_queries {
        data = all_data_to_hash[i];
        res = malloc_vec(1);
        slice_hash(pointer_to_zero_vector, data, res, half_len);
        all_resulting_hashes[i] = res;
    }
    return;    
}

fn merkle_verif_batch_dynamic(n_paths, leaves_digests, leave_positions, root, height) {
    if height == MERKLE_HEIGHT_0 {
        merkle_verif_batch_const(n_paths, leaves_digests, leave_positions, root, MERKLE_HEIGHT_0);
        return;
    }
    if height == MERKLE_HEIGHT_1 {
        merkle_verif_batch_const(n_paths, leaves_digests, leave_positions, root, MERKLE_HEIGHT_1);
        return;
    }
    if height == MERKLE_HEIGHT_2 {
        merkle_verif_batch_const(n_paths, leaves_digests, leave_positions, root, MERKLE_HEIGHT_2);
        return;
    }
    if height == MERKLE_HEIGHT_3 {
        merkle_verif_batch_const(n_paths, leaves_digests, leave_positions, root, MERKLE_HEIGHT_3);
        return;
    }

    print(12345555);
    print(height);
    panic();
}

fn merkle_verif_batch_const(n_paths, leaves_digests, leave_positions, root, const height) {
    // n_paths: F
    // leaves_digests: pointer to a slice of n_paths vectorized pointers, each pointing to 1 chunk of 8 field elements
    // leave_positions: pointer to a slice of n_paths field elements (each < 2^height)
    // root: vectorized pointer to 1 chunk of 8 field elements
    // height: F

    for i in 0..n_paths {
        merkle_verify(leaves_digests[i], leave_positions[i], root, height);
    }

    return;
}


fn whir_round(fs_state, prev_root, folding_factor, two_pow_folding_factor, merkle_leaves_in_basefield, num_queries, domain_size, claimed_sum, grinding_bits) -> 7 {
    fs_state_7, folding_randomness, new_claimed_sum_a = sumcheck(fs_state, folding_factor, claimed_sum);

    fs_state_8, root, ood_point, ood_eval = parse_commitment(fs_state_7);

    fs_state_11, circle_values, folds = 
        sample_stir_indexes_and_fold(fs_state_8, num_queries, merkle_leaves_in_basefield, folding_factor, two_pow_folding_factor, domain_size, prev_root, folding_randomness, grinding_bits);

    fs_state_12, combination_randomness_gen = fs_sample_ef(fs_state_11);

    combination_randomness_powers = powers(combination_randomness_gen, num_queries + 1); // "+ 1" because of one OOD sample

    claimed_sum_supplement_side = malloc(5);
    dot_product_ee_dynamic(folds, combination_randomness_powers + DIM, claimed_sum_supplement_side, num_queries);

    claimed_sum_supplement = add_extension_ret(claimed_sum_supplement_side, ood_eval);
    new_claimed_sum_b = add_extension_ret(claimed_sum_supplement, new_claimed_sum_a);

    return fs_state_12, folding_randomness, ood_point, root, circle_values, combination_randomness_powers, new_claimed_sum_b;
}

fn copy_chunk(src, dst) {
    // src: pointer to 8 F
    // dst: pointer to 8 F
    for i in 0..8 unroll { dst[i] = src[i]; }
    return;
}

fn copy_chunk_vec(src, dst) {
    zero = 0; // TODO
    add_extension(src, zero, dst);
    return;
}

fn powers(alpha, n) -> 1 {
    // alpha: EF
    // n: F

    res = malloc(n * DIM);
    set_to_one(res);
    for i in 0..n - 1 {
        mul_extension(res + i*DIM, alpha, res + (i + 1)*DIM);
    }
    return res;
}

fn unit_root_pow_dynamic(domain_size, index_bits) -> 1 {
    // index_bits is a pointer to domain_size bits
    match domain_size {
        0 => {  } // unreachable
        1 => { res = unit_root_pow_const(1, index_bits); }
        2 => { res = unit_root_pow_const(2, index_bits); }
        3 => { res = unit_root_pow_const(3, index_bits); }
        4 => { res = unit_root_pow_const(4, index_bits); }
        5 => { res = unit_root_pow_const(5, index_bits); }
        6 => { res = unit_root_pow_const(6, index_bits); }
        7 => { res = unit_root_pow_const(7, index_bits); }
        8 => { res = unit_root_pow_const(8, index_bits); }
        9 => { res = unit_root_pow_const(9, index_bits); }
        10 => { res = unit_root_pow_const(10, index_bits); }
        11 => { res = unit_root_pow_const(11, index_bits); }
        12 => { res = unit_root_pow_const(12, index_bits); }
        13 => { res = unit_root_pow_const(13, index_bits); }
        14 => { res = unit_root_pow_const(14, index_bits); }
        15 => { res = unit_root_pow_const(15, index_bits); }
        16 => { res = unit_root_pow_const(16, index_bits); }
        17 => { res = unit_root_pow_const(17, index_bits); }
        18 => { res = unit_root_pow_const(18, index_bits); }
        19 => { res = unit_root_pow_const(19, index_bits); }
        20 => { res = unit_root_pow_const(20, index_bits); }
        21 => { res = unit_root_pow_const(21, index_bits); }
        22 => { res = unit_root_pow_const(22, index_bits); }
    }
    return res;
}

fn unit_root_pow_const(const domain_size, index_bits) -> 1 {
    prods = malloc(domain_size);
    prods[0] = ((index_bits[0] * ROOT**(2**(TWO_ADICITY - domain_size))) + (1 - index_bits[0]));
    for i in 1..domain_size unroll {
        prods[i] = prods[i - 1] * ((index_bits[i] * ROOT**(2**(TWO_ADICITY - domain_size + i))) + (1 - index_bits[i]));
    }
    return prods[domain_size - 1];
}

fn dot_product_ee_dynamic(a, b, res, n) { 
    if n == 16 {
        dot_product_ee(a, b, res, 16);
        return;
    }
    if n == NUM_QUERIES_0 {
        dot_product_ee(a, b, res, NUM_QUERIES_0);
        return;
    }
    if n == NUM_QUERIES_1 {
        dot_product_ee(a, b, res, NUM_QUERIES_1);
        return;
    }
    if n == NUM_QUERIES_2 {
        dot_product_ee(a, b, res, NUM_QUERIES_2);
        return;
    }
    if n == NUM_QUERIES_3 {
        dot_product_ee(a, b, res, NUM_QUERIES_3);
        return;
    }
    if n == NUM_QUERIES_0 + 1 {
        dot_product_ee(a, b, res, NUM_QUERIES_0 + 1);
        return;
    }
    if n == NUM_QUERIES_1 + 1 {
        dot_product_ee(a, b, res, NUM_QUERIES_1 + 1);
        return;
    }
    if n == NUM_QUERIES_2 + 1 {
        dot_product_ee(a, b, res, NUM_QUERIES_2 + 1);
        return;
    }
    if n == NUM_QUERIES_3 + 1 {
        dot_product_ee(a, b, res, NUM_QUERIES_3 + 1);
        return;
    }

    TODO_dot_product_ee_dynamic = 0;
    print(TODO_dot_product_ee_dynamic, n);
    panic();
}

fn poly_eq_extension(point, n, two_pow_n) -> 1 {
    // Example: for n = 2: eq(x, y) = [(1 - x)(1 - y), (1 - x)y, x(1 - y), xy]

    if n == 0 {
        res = malloc(DIM);
        set_to_one(res);
        return res;
    }

    res = malloc(two_pow_n * DIM);

    inner_res = poly_eq_extension(point + DIM, n - 1, two_pow_n / 2);

    two_pow_n_minus_1 = two_pow_n / 2;

    for i in 0..two_pow_n_minus_1 {
        mul_extension(point, inner_res + i*DIM, res + (two_pow_n_minus_1 + i) * DIM);
        sub_extension(inner_res + i*DIM, res + (two_pow_n_minus_1 + i) * DIM, res + i*DIM);
    }
    
    return res;
}

fn poly_eq_base(point, n) -> 1 {
    match n {
        0 => {  } // unreachable
        1 => { res = poly_eq_base_1(point); }
        2 => { res = poly_eq_base_2(point); }
        3 => { res = poly_eq_base_3(point); }
        4 => { res = poly_eq_base_4(point); }
        5 => { res = poly_eq_base_5(point); }
        6 => { res = poly_eq_base_6(point); }
        7 => { res = poly_eq_base_7(point); }
    }
    return res;
}

fn poly_eq_base_7(point) -> 1 {
    // n = 7
    // return a (normal) pointer to 2^n base field elements, corresponding to the "equality polynomial" at point
    // Example: for n = 2: eq(x, y) = [(1 - x)(1 - y), (1 - x)y, x(1 - y), xy]

    res = malloc(128);

    inner_res = poly_eq_base_6(point + 1);

    for i in 0..64 unroll {
        res[64 + i] = inner_res[i] * point[0];
        res[i] = inner_res[i] - res[64 + i];
    }
    
    return res;
}

fn poly_eq_base_6(point) -> 1 {
    // n = 6
    res = malloc(64);
    
    inner_res = poly_eq_base_5(point + 1);
    
    for i in 0..32 unroll {
        res[32 + i] = inner_res[i] * point[0];
        res[i] = inner_res[i] - res[32 + i];
    }
    
    return res;
}

fn poly_eq_base_5(point) -> 1 {
    // n = 5
    res = malloc(32);
    
    inner_res = poly_eq_base_4(point + 1);
    
    for i in 0..16 unroll {
        res[16 + i] = inner_res[i] * point[0];
        res[i] = inner_res[i] - res[16 + i];
    }
    
    return res;
}

fn poly_eq_base_4(point) -> 1 {
    // n = 4
    res = malloc(16);
    
    inner_res = poly_eq_base_3(point + 1);
    
    for i in 0..8 unroll {
        res[8 + i] = inner_res[i] * point[0];
        res[i] = inner_res[i] - res[8 + i];
    }
    
    return res;
}

fn poly_eq_base_3(point) -> 1 {
    // n = 3
    res = malloc(8);
    
    inner_res = poly_eq_base_2(point + 1);
    
    for i in 0..4 unroll {
        res[4 + i] = inner_res[i] * point[0];
        res[i] = inner_res[i] - res[4 + i];
    }
    
    return res;
}

fn poly_eq_base_2(point) -> 1 {
    // n = 2
    res = malloc(4);
    
    inner_res = poly_eq_base_1(point + 1);
    
    for i in 0..2 unroll {
        res[2 + i] = inner_res[i] * point[0];
        res[i] = inner_res[i] - res[2 + i];
    }
    
    return res;
}

fn poly_eq_base_1(point) -> 1 {
    // n = 1
    // Base case: eq(x) = [1 - x, x]
    res = malloc(2);
    
    res[1] = point[0];
    res[0] = 1 - res[1];
    
    return res;
}


fn pow(a, b) -> 1 {
    if b == 0 {
        return 1; // a^0 = 1
    } else {
        p = pow(a, b - 1);
        return a * p;
    }
}

fn sample_bits_dynamic(fs_state, n_samples, K) -> 2 {
    if n_samples == NUM_QUERIES_0 {
        new_fs_state, sampled_bits = sample_bits_const(fs_state, NUM_QUERIES_0, K);
        return new_fs_state, sampled_bits;
    }
    if n_samples == NUM_QUERIES_1 {
        new_fs_state, sampled_bits = sample_bits_const(fs_state, NUM_QUERIES_1, K);
        return new_fs_state, sampled_bits;
    }
    if n_samples == NUM_QUERIES_2 {
        new_fs_state, sampled_bits = sample_bits_const(fs_state, NUM_QUERIES_2, K);
        return new_fs_state, sampled_bits;
    }
    if n_samples == NUM_QUERIES_3 {
        new_fs_state, sampled_bits = sample_bits_const(fs_state, NUM_QUERIES_3, K);
        return new_fs_state, sampled_bits;
    }
    print(n_samples);
    print(999333);
    panic();
}

fn sample_bits_const(fs_state, const n_samples, K) -> 2 {
    // return the updated fs_state, and a pointer to n pointers, each pointing to 31 (boolean) field elements,
    //  ... followed by the n corresponding sampled field elements (where we only look at the first K bits)
    samples = malloc(n_samples);
    new_fs_state = fs_sample_helper(fs_state, n_samples, samples);
    sampled_bits = malloc(n_samples * 2);
    for i in 0..n_samples unroll {
        bits, partial_sum = checked_decompose_bits(samples[i], K);
        sampled_bits[i] = bits;
        sampled_bits[n_samples + i] = partial_sum;
    }

    return new_fs_state, sampled_bits;
}

fn checked_decompose_bits(a, k) -> 2 {
    // return a pointer to the 31 bits of a
    // .. and the partial value, reading the first K bits
    bits = decompose_bits(a); // hint

    for i in 0..F_BITS unroll {
        assert bits[i] * (1 - bits[i]) == 0;
    }
    sums = malloc(F_BITS);
    sums[0] = bits[0];
    for i in 1..F_BITS unroll {
        sums[i] = sums[i - 1] + bits[i] * 2**i;
    }
    assert a == sums[F_BITS - 1];
    partial_sum = sums[k - 1];
    return bits, partial_sum;
}

fn degree_two_polynomial_sum_at_0_and_1(coeffs) -> 1 {
    // coeffs is a normal pointer to 3 consecutive EF element
    // return a normal pointer to 1 ef element
    a = add_extension_ret(coeffs, coeffs);
    b = add_extension_ret(a, coeffs + DIM);
    c = add_extension_ret(b, coeffs + (DIM * 2));
    return c;
}

fn degree_two_polynomial_eval(coeffs, point) -> 1 {
    // coefs: normal pointer to 3 consecutive EF element
    // point: normal pointer to 1 EF element
    // return a normal pointer to 1 EF element
    point_squared = mul_extension_ret(point, point);
    a_xx = mul_extension_ret(coeffs + DIM * 2, point_squared);
    b_x = mul_extension_ret(coeffs + DIM, point);
    c = coeffs;
    res_0 = add_extension_ret(a_xx, b_x);
    res_1 = add_extension_ret(res_0, c);
    return res_1;
}

fn parse_commitment(fs_state) -> 4 {
    fs_state_1, root = fs_receive(fs_state, 1); // vectorized pointer of len 1
    fs_state_2, ood_point = fs_sample_ef(fs_state_1);
    fs_state_3, ood_eval = fs_receive_ef(fs_state_2, 1);
    return fs_state_3, root, ood_point, ood_eval;
}

// FIAT SHAMIR layout:
// 0 -> transcript (vectorized pointer)
// 1 -> vectorized pointer to first half of sponge state
// 2 -> vectorized pointer to second half of sponge state
// 3 -> output_buffer_size

fn fs_new(transcript) -> 1 {
    // transcript is a (vectorized) pointer
    // TODO domain separator
    fs_state = malloc(4);
    fs_state[0] = transcript;
    fs_state[1] = pointer_to_zero_vector; // first half of sponge state
    fs_state[2] = pointer_to_zero_vector; // second half of sponge state
    fs_state[3] = 0; // output buffer size

    return fs_state;
}

fn fs_grinding(fs_state, bits) -> 1 {
    // WARNING: should not be called 2 times in a row without duplexing in between

    if bits == 0 {
        return fs_state; // no grinding
    }

    transcript_ptr = fs_state[0] * 8;
    l_ptr = fs_state[1] * 8;
    
    new_l = malloc_vec(1);
    new_l_ptr = new_l * 8;
    new_l_ptr[0] = transcript_ptr[0];
    for i in 1..8 unroll {
        new_l_ptr[i] = l_ptr[i];
    }

    l_r_updated = malloc_vec(2);
    poseidon16(new_l, fs_state[2], l_r_updated, PERMUTATION);
    new_fs_state = malloc(4);
    new_fs_state[0] = fs_state[0] + 1; // read one 1 chunk of 8 field elements (7 are useless)
    new_fs_state[1] = l_r_updated;
    new_fs_state[2] = l_r_updated + 1;
    new_fs_state[3] = 7; // output_buffer_size

    l_updated_ptr = l_r_updated* 8;
    sampled = l_updated_ptr[7];
    sampled_bits, _ = checked_decompose_bits(sampled, 1); // 1 is useless here, could be anything
    for i in 0..bits {
        assert sampled_bits[i] == 0;
    }
    return new_fs_state;
}

fn less_than_8(a) inline -> 1 {
    // TODO range check
    if a * (a - 1) * (a - 2) * (a - 3) * (a - 4) * (a - 5) * (a - 6) * (a - 7) == 0 {
        return 1; // a < 8
    } else {
        return 0; // a >= 8
    }
}

fn fs_sample_ef(fs_state) -> 2 {
    // return the updated fs_state, and a normal pointer to 1 EF element
    res = malloc(DIM);
    new_fs_state = fs_sample_helper(fs_state, DIM, res);
    return new_fs_state, res;
}

fn fs_sample_helper(fs_state, n, res) -> 1 {
    // return the updated fs_state
    // fill res with n field elements

    output_buffer_size = fs_state[3];
    output_buffer_ptr = fs_state[1] * 8;

    for i in 0..n {
        if output_buffer_size - i == 0 {
            break;
        }
        res[i] = output_buffer_ptr[output_buffer_size - 1 - i];
    }

    finished = less_than_8(output_buffer_size - n);
    if finished == 1 {
        // no duplexing
        new_fs_state = malloc(4);
        new_fs_state[0] = fs_state[0];
        new_fs_state[1] = fs_state[1];
        new_fs_state[2] = fs_state[2];
        new_fs_state[3] = output_buffer_size - n;
        return new_fs_state;
    }

    // duplexing
    l_r = malloc_vec(2);
    poseidon16(fs_state[1], fs_state[2], l_r, PERMUTATION);
    new_fs_state = malloc(4);
    new_fs_state[0] = fs_state[0];
    new_fs_state[1] = l_r;
    new_fs_state[2] = l_r + 1;
    new_fs_state[3] = 8; // output_buffer_size

    remaining = n - output_buffer_size;
    if remaining == 0 {
        return new_fs_state;
    }

    shifted_res = res + output_buffer_size;
    final_res = fs_sample_helper(new_fs_state, remaining, shifted_res);
    return final_res;

}

fn fs_hint(fs_state, n) -> 2 {
    // return the updated fs_state, and a vectorized pointer to n chunk of 8 field elements

    res = fs_state[0];
    new_fs_state = malloc(4);
    new_fs_state[0] = res + n;
    new_fs_state[1] = fs_state[1];
    new_fs_state[2] = fs_state[2];
    new_fs_state[3] = fs_state[3];
    return new_fs_state, res; 
}

fn fs_receive_ef(fs_state, n) -> 2 {
    match n {
        0 => {  } // unreachable
        1 => { final_fs_state, res = fs_receive_ef_const(fs_state, 1); }
        2 => { final_fs_state, res = fs_receive_ef_const(fs_state, 2); }
        3 => { final_fs_state, res = fs_receive_ef_const(fs_state, 3); }
        4 => { final_fs_state, res = fs_receive_ef_const(fs_state, 4); }
        5 => { final_fs_state, res = fs_receive_ef_const(fs_state, 5); }
        6 => { final_fs_state, res = fs_receive_ef_const(fs_state, 6); }
        7 => { final_fs_state, res = fs_receive_ef_const(fs_state, 7); }
        8 => { final_fs_state, res = fs_receive_ef_const(fs_state, 8); }
        9 => { final_fs_state, res = fs_receive_ef_const(fs_state, 9); }
        10 => { final_fs_state, res = fs_receive_ef_const(fs_state, 10); }
    }
    return final_fs_state, res;
}


fn fs_receive_ef_const(fs_state, const n) -> 2 {
    // return the updated fs_state, and a (normal) pointer to n consecutive EF elements
    final_fs_state = fs_observe(fs_state, n);
    res = malloc(n * DIM);
    // TODO optimize with dot_product
    for i in 0..n unroll { 
        ptr = (fs_state[0] + i) * 8;
        for j in 0..DIM unroll {
            res[i * DIM + j] = ptr[j];
        }
        for j in DIM..8 unroll {
            assert ptr[j] == 0;
        }
    }

    return final_fs_state, res;
}

fn fs_receive(fs_state, n) -> 2 {
    // return the updated fs_state, and a vectorized pointer to n chunk of 8 field elements

    res = fs_state[0];
    final_fs_state = fs_observe(fs_state, n);
    return final_fs_state, res;
}

fn fs_observe(fs_state, n) -> 1 {
    // observe n chunk of 8 field elements from the transcript
    // and return the updated fs_state
    // duplexing
    l_r = malloc_vec(2);
    poseidon16(fs_state[0], fs_state[2], l_r, PERMUTATION);
    new_fs_state = malloc(4);
    new_fs_state[0] = fs_state[0] + 1;
    new_fs_state[1] = l_r;
    new_fs_state[2] = l_r + 1;
    new_fs_state[3] = 8; // output_buffer_size

    if n == 1 {
        return new_fs_state;
    } else {
        final_fs_state = fs_observe(new_fs_state, n - 1);
        return final_fs_state;
    }
}

fn fs_print_state(fs_state) {
    left = fs_state[1] * 8;
    for i in 0..8 {
        print(left[i]);
    }
    right = fs_state[2] * 8;
    for i in 0..8 {
        print(right[i]);
    }
    return;
}

fn mul_extension_ret(a, b) inline -> 1 {
    c = malloc(DIM);
    dot_product_ee(a, b, c, 1);
    return c;
}

fn mul_extension(a, b, c) inline {
    dot_product_ee(a, b, c, 1);
    return;
}

fn add_extension_ret(a, b) inline -> 1 {
    // TODO if a and b are adjacent we can do it in one cycle using the dot_product precompile
    c = malloc(DIM);
    for i in 0..DIM unroll {
        c[i] = a[i] + b[i];
    }
    return c;
}

fn add_extension(a, b, c) inline {
    // TODO if a and b are adjacent we can do it in one cycle using the dot_product precompile
    for i in 0..DIM unroll {
        c[i] = a[i] + b[i];
    }
    return;
}

fn sub_extension(a, b, c) inline {
    // TODO if a and b are adjacent we can do it in one cycle using the dot_product precompile
    for i in 0..DIM unroll {
        c[i] = a[i] - b[i];
    }
    return;
}

fn assert_eq_extension(a, b) inline {
    dot_product_ee(a, pointer_to_one_vector * 8, b, 1);
    return;
}

// TODO improve
fn assert_eq_vec(a, b) inline {
    a_ptr = a * 8;
    b_ptr = b * 8;
    dot_product_ee(a_ptr, pointer_to_one_vector * 8, b_ptr, 1);
    dot_product_ee(a_ptr + (8 - DIM), pointer_to_one_vector * 8, b_ptr + (8 - DIM), 1);
    return;
}

fn set_to_one(a) inline {
    a[0] = 1;
    for i in 1..DIM unroll { a[i] = 0; }
    return;
}

fn print_vec(a) {
    print_many_vec(a, 1);
    return;
}

fn print_ef(a) {
    for i in 0..DIM unroll {
        print(a[i]);
    }
    return;
}

fn print_many_vec(a, n) {
    print_many(a * 8, n * 8);
    return;
}

fn print_many(a, n) {
    for i in 0..n {
        print(a[i]);
    }
    return;
}

fn next_multiple_of_8(const a) -> 1 {
    return a + (8 - (a % 8)) % 8;
}

