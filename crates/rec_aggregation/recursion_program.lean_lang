
// 1 OOD QUERY PER ROUND
// 0 GRINDING IN SUMCHECK -> TODO

const F_BITS = 31; // koala-bear = 31 bits
const DIM = 5; // extension degree

const N_VARS = N_VARS_PLACEHOLDER;
const LOG_INV_RATE = LOG_INV_RATE_PLACEHOLDER; 
const N_ROUNDS = 3; // TODO make it a parameter

const PADDING_FOR_INITIAL_MERKLE_LEAVES = PADDING_FOR_INITIAL_MERKLE_LEAVES_PLACEHOLDER;

const FOLDING_FACTOR_0 = FOLDING_FACTOR_0_PLACEHOLDER;
const FOLDING_FACTOR_1 = FOLDING_FACTOR_1_PLACEHOLDER;
const FOLDING_FACTOR_2 = FOLDING_FACTOR_2_PLACEHOLDER;
const FOLDING_FACTOR_3 = FOLDING_FACTOR_3_PLACEHOLDER;

const FINAL_VARS = N_VARS - (FOLDING_FACTOR_0 + FOLDING_FACTOR_1 + FOLDING_FACTOR_2 + FOLDING_FACTOR_3);

const RS_REDUCTION_FACTOR_0 = RS_REDUCTION_FACTOR_0_PLACEHOLDER;
const RS_REDUCTION_FACTOR_1 = 1;
const RS_REDUCTION_FACTOR_2 = 1;
const RS_REDUCTION_FACTOR_3 = 1;

const NUM_QUERIES_0 = NUM_QUERIES_0_PLACEHOLDER;
const NUM_QUERIES_1 = NUM_QUERIES_1_PLACEHOLDER;
const NUM_QUERIES_2 = NUM_QUERIES_2_PLACEHOLDER;
const NUM_QUERIES_3 = NUM_QUERIES_3_PLACEHOLDER;

const GRINDING_BITS_0 = GRINDING_BITS_0_PLACEHOLDER;
const GRINDING_BITS_1 = GRINDING_BITS_1_PLACEHOLDER;
const GRINDING_BITS_2 = GRINDING_BITS_2_PLACEHOLDER;
const GRINDING_BITS_3 = GRINDING_BITS_3_PLACEHOLDER;

const TWO_ADICITY = 24;
const ROOT = 1791270792; // of order 2^TWO_ADICITY

fn main() {
    transcript_start = public_input_start / 8;
    fs_state = fs_new(transcript_start);

    fs_state_0, root_0, ood_point_0, ood_eval_0 = parse_commitment(fs_state);

    // In the future point / eval will come from the PIOP
    point_vector_len = next_multiple_of_8(N_VARS * DIM);
    fs_state_1, pcs_point_vec = fs_hint(fs_state_0, point_vector_len / 8);
    pcs_point = pcs_point_vec * 8;
    fs_state_2, pcs_eval_vec = fs_hint(fs_state_1, 1);
    pcs_eval = pcs_eval_vec * 8;

    fs_state_3, _ = fs_hint(fs_state_2, PADDING_FOR_INITIAL_MERKLE_LEAVES);
    fs_state_4, combination_randomness_gen_0 = fs_sample_ef(fs_state_3);

    claimed_sum_side = mul_extension_ret(combination_randomness_gen_0, pcs_eval);
    claimed_sum_0 = add_extension_ret(ood_eval_0, claimed_sum_side);
    domain_size_0 = N_VARS + LOG_INV_RATE;
    fs_state_5, folding_randomness_1, ood_point_1, root_1, circle_values_1, combination_randomness_powers_1, claimed_sum_1 = 
        whir_round(fs_state_4, root_0, FOLDING_FACTOR_0, 2**FOLDING_FACTOR_0, 1, NUM_QUERIES_0, domain_size_0, claimed_sum_0, GRINDING_BITS_0);

    domain_size_1 = domain_size_0 - RS_REDUCTION_FACTOR_0;
    fs_state_6, folding_randomness_2, ood_point_2, root_2, circle_values_2, combination_randomness_powers_2, claimed_sum_2 = 
        whir_round(fs_state_5, root_1, FOLDING_FACTOR_1, 2**FOLDING_FACTOR_1, 0, NUM_QUERIES_1, domain_size_1, claimed_sum_1, GRINDING_BITS_1);

    domain_size_2 = domain_size_1 - RS_REDUCTION_FACTOR_1;
    fs_state_7, folding_randomness_3, ood_point_3, root_3, circle_values_3, combination_randomness_powers_3, claimed_sum_3 = 
        whir_round(fs_state_6, root_2, FOLDING_FACTOR_2, 2**FOLDING_FACTOR_2, 0, NUM_QUERIES_2, domain_size_2, claimed_sum_2, GRINDING_BITS_2);

    domain_size_3 = domain_size_2 - RS_REDUCTION_FACTOR_2;
    fs_state_8, folding_randomness_4, final_claimed_sum = sumcheck(fs_state_7, FOLDING_FACTOR_3, claimed_sum_3);
    
    fs_state_9, final_coeffcients_unpacked = fs_receive(fs_state_8, 2**FINAL_VARS);
    final_coeffcients = malloc(2**FINAL_VARS * DIM);
    for i in 0..2**FINAL_VARS {
        assert_eq_extension((final_coeffcients_unpacked + i) * 8, final_coeffcients + i*DIM);
    }

    fs_state_10, final_circle_values, final_folds =
        sample_stir_indexes_and_fold(fs_state_9, NUM_QUERIES_3, 0, FOLDING_FACTOR_3, 2**FOLDING_FACTOR_3, domain_size_3, root_3, folding_randomness_4, GRINDING_BITS_3);

    
    for i in 0..NUM_QUERIES_3 {
        powers_of_2_rev = powers_of_two_rev_base_const(final_circle_values[i], FINAL_VARS);
        poly_eq = poly_eq_base(powers_of_2_rev, FINAL_VARS, 2**FINAL_VARS);
        final_pol_evaluated_on_circle = malloc(DIM);
        dot_product_base_extension(poly_eq, final_coeffcients, final_pol_evaluated_on_circle, 2**FINAL_VARS); // TODO use multilinear eval instead
        assert_eq_extension(final_pol_evaluated_on_circle, final_folds + i*DIM);
    }

    fs_state_11, folding_randomness_5, end_sum = sumcheck(fs_state_10, FINAL_VARS, final_claimed_sum);

    folding_randomness_global = malloc(N_VARS * DIM);

    ffs = malloc(N_ROUNDS + 2);
    ffs[0] = FOLDING_FACTOR_0; ffs[1] = FOLDING_FACTOR_1; ffs[2] = FOLDING_FACTOR_2; ffs[3] = FOLDING_FACTOR_3; ffs[4] = FINAL_VARS;
    frs = malloc(N_ROUNDS + 2);
    frs[0] = folding_randomness_5; frs[1] = folding_randomness_4; frs[2] = folding_randomness_3; frs[3] = folding_randomness_2; frs[4] = folding_randomness_1;
    ffs_sums = malloc(N_ROUNDS + 2);
    ffs_sums[0] = FOLDING_FACTOR_0;
    for i in 0..N_ROUNDS + 1 {
        ffs_sums[i + 1] = ffs_sums[i] + ffs[i + 1];
    }
    for i in 0..N_ROUNDS + 2 {
        start = folding_randomness_global + (N_VARS - ffs_sums[N_ROUNDS + 1 - i]) * DIM;
        for j in 0..ffs[N_ROUNDS + 1 - i] {
            assert_eq_extension(frs[i] + j*DIM, start + j*DIM);
        }
    }

    ood_0_expanded_from_univariate = powers_of_two_rev_extension(ood_point_0, N_VARS);
    s0 = eq_mle_extension(ood_0_expanded_from_univariate, folding_randomness_global, N_VARS);
    s1 = eq_mle_extension(pcs_point, folding_randomness_global, N_VARS);
    s3 = mul_extension_ret(s1, combination_randomness_gen_0);
    s4 = add_extension_ret(s0, s3);

    weight_sums = malloc(N_ROUNDS + 1);
    weight_sums[0] = s4;

    ood_points = malloc(N_ROUNDS + 1); ood_points[0] = ood_point_0; ood_points[1] = ood_point_1; ood_points[2] = ood_point_2; ood_points[3] = ood_point_3;
    num_queries = malloc(N_ROUNDS + 1); num_queries[0] = NUM_QUERIES_0; num_queries[1] = NUM_QUERIES_1; num_queries[2] = NUM_QUERIES_2; num_queries[3] = NUM_QUERIES_3;
    circle_values = malloc(N_ROUNDS + 1); circle_values[0] = circle_values_1; circle_values[1] = circle_values_2; circle_values[2] = circle_values_3; circle_values[3] = final_circle_values;
    combination_randomness_powers = malloc(N_ROUNDS); combination_randomness_powers[0] = combination_randomness_powers_1; combination_randomness_powers[1] = combination_randomness_powers_2; combination_randomness_powers[2] = combination_randomness_powers_3;

    for i in 0..N_ROUNDS {
        ood_expanded_from_univariate = powers_of_two_rev_extension(ood_points[i + 1], N_VARS - ffs_sums[i]);
        s5 = eq_mle_extension(ood_expanded_from_univariate, folding_randomness_global, N_VARS - ffs_sums[i]);
        s6s = malloc((num_queries[i] + 1) * DIM);
        assert_eq_extension(s5, s6s);
        circle_value_i = circle_values[i];
        for j in 0..num_queries[i] {
            expanded_from_univariate = powers_of_two_rev_base_dynamic(circle_value_i[j], N_VARS - ffs_sums[i]);
            temp = eq_mle_extension_base_dynamic(expanded_from_univariate, folding_randomness_global, N_VARS - ffs_sums[i]);
            assert_eq_extension(temp, s6s + (j + 1) * DIM);
        }
        s7 = malloc(DIM);
        dot_product_dynamic(s6s, combination_randomness_powers[i], s7, num_queries[i] + 1);
        wsum = add_extension_ret(weight_sums[i], s7);
        weight_sums[i+1] = wsum;
    }

    evaluation_of_weights = weight_sums[N_ROUNDS];
    poly_eq_final = poly_eq_extension(folding_randomness_5, FINAL_VARS, 2**FINAL_VARS);
    final_value = malloc(DIM);
    dot_product(poly_eq_final, final_coeffcients, final_value, 2**FINAL_VARS);
    evaluation_of_weights_times_final_value = mul_extension_ret(evaluation_of_weights, final_value);
    assert_eq_extension(evaluation_of_weights_times_final_value, end_sum);
    return;
}

fn eq_mle_extension(a, b, n) -> 1 {

    buff = malloc(n*DIM);

    for i in 0..n {
        shift = i * DIM;
        ai = a + shift;
        bi = b + shift;
        buffi = buff + shift;
        ab = mul_extension_ret(ai, bi);
        buffi[0] = 1 + 2 * ab[0] - ai[0] - bi[0];
        for j in 1..DIM unroll {
            buffi[j] = 2 * ab[j] - ai[j] - bi[j];
        }
    }

    prods = malloc(n*DIM);
    assert_eq_extension(buff, prods);
    for i in 0..n - 1 {
        mul_extension(prods + i*DIM, buff + (i + 1)*DIM, prods + (i + 1)*DIM);
    }

    return prods + (n - 1) * DIM;
}

fn eq_mle_extension_base_dynamic(a, b, n) -> 1 {
    if n == N_VARS - FOLDING_FACTOR_0 {
        res = eq_mle_extension_base_const(a, b, N_VARS - FOLDING_FACTOR_0);
        return res;
    }
    if n == N_VARS - FOLDING_FACTOR_0 - FOLDING_FACTOR_1 {
        res = eq_mle_extension_base_const(a, b, N_VARS - FOLDING_FACTOR_0 - FOLDING_FACTOR_1);
        return res;
    }
    if n == N_VARS - FOLDING_FACTOR_0 - FOLDING_FACTOR_1 - FOLDING_FACTOR_2 {
        res = eq_mle_extension_base_const(a, b, N_VARS - FOLDING_FACTOR_0 - FOLDING_FACTOR_1 - FOLDING_FACTOR_2);
        return res;
    }
    TODO_eq_mle_extension_base_dynamicc = n;
    print(TODO_eq_mle_extension_base_dynamicc);
    panic();
}

fn eq_mle_extension_base_const(a, b, const n) -> 1 {
    // a: base
    // b: extension

    buff = malloc(n*DIM);

    for i in 0..n unroll {
        ai = a[i];
        bi = b + i*DIM;
        buffi = buff + i*DIM;
        ai_double = ai * 2;
        buffi[0] = 1 + ai_double * bi[0] - ai - bi[0];
        for j in 1..DIM unroll {
            buffi[j] = ai_double * bi[j] - bi[j];
        }
    }

    prods = malloc(n*DIM);
    assert_eq_extension(buff, prods);
    for i in 0..n - 1 unroll {
        mul_extension(prods + i*DIM, buff + (i + 1)*DIM, prods + (i + 1)*DIM);
    }
    return prods + (n - 1) * DIM;
}

fn powers_of_two_rev_base_dynamic(alpha, n) -> 1 {
    if n == N_VARS - FOLDING_FACTOR_0 {
        res = powers_of_two_rev_base_const(alpha, N_VARS - FOLDING_FACTOR_0);
        return res;
    }
    if n == N_VARS - FOLDING_FACTOR_0 - FOLDING_FACTOR_1 {
        res = powers_of_two_rev_base_const(alpha, N_VARS - FOLDING_FACTOR_0 - FOLDING_FACTOR_1);
        return res;
    }
    if n == N_VARS - FOLDING_FACTOR_0 - FOLDING_FACTOR_1 - FOLDING_FACTOR_2 {
        res = powers_of_two_rev_base_const(alpha, N_VARS - FOLDING_FACTOR_0 - FOLDING_FACTOR_1 - FOLDING_FACTOR_2);
        return res;
    }
    TODO_powers_of_two_rev_base_dynamic = n;
    print(TODO_powers_of_two_rev_base_dynamic);
    panic();
}

fn powers_of_two_rev_base_const(alpha, const n) -> 1 {
    // "expand_from_univariate"
    // alpha: F

    res = malloc(n);
    res[n - 1] = alpha;
    for i in 1..n unroll {
        res[n - 1 - i] = res[n - i] * res[n - i];
    }
    return res;
}

fn powers_of_two_rev_extension(alpha, n) -> 1 {
    // "expand_from_univariate"

    res = malloc(n*DIM);
    assert_eq_extension(alpha, res + (n - 1)*DIM);
    for i in 1..n {
        mul_extension(res + (n - i)*DIM, res + (n - i)*DIM, res + (n - 1 - i)*DIM);
    }
    return res;
}

fn sumcheck(fs_state, n_steps, claimed_sum) -> 3 {

    fs_states_a = malloc(n_steps + 1);
    fs_states_a[0] = fs_state;

    claimed_sums = malloc(n_steps + 1);
    claimed_sums[0] = claimed_sum;

    folding_randomness = malloc(n_steps * DIM); // in reverse order.

    for sc_round in 0..n_steps {
        fs_state_5, poly = fs_receive_ef(fs_states_a[sc_round], 3);
        sum_over_boolean_hypercube = degree_two_polynomial_sum_at_0_and_1(poly);
        assert_eq_extension(sum_over_boolean_hypercube, claimed_sums[sc_round]);
        fs_state_6, rand = fs_sample_ef(fs_state_5);
        fs_states_a[sc_round + 1] = fs_state_6;
        new_claimed_sum = degree_two_polynomial_eval(poly, rand);
        claimed_sums[sc_round + 1] = new_claimed_sum;
        assert_eq_extension(rand, folding_randomness + (n_steps - 1 - sc_round) * DIM);
    }

    new_state = fs_states_a[n_steps];
    new_claimed_sum = claimed_sums[n_steps];

    return new_state, folding_randomness, new_claimed_sum;
}

fn sample_stir_indexes_and_fold(fs_state, num_queries, merkle_leaves_in_basefield, folding_factor, two_pow_folding_factor, domain_size, prev_root, folding_randomness, grinding_bits) -> 3 {

    fs_state_8 = fs_grinding(fs_state, grinding_bits);
    fs_state_9, stir_challenges_indexes = sample_bits(fs_state_8, num_queries);

    answers = malloc(num_queries); // a vector of vectorized pointers, each pointing to `two_pow_folding_factor` field elements (base if first rounds, extension otherwise)
    fs_states_b = malloc(num_queries + 1);
    fs_states_b[0] = fs_state_9;
    
    // the number of chunk of 8 field elements per merkle leaf opened
    if merkle_leaves_in_basefield == 1 {
        n_chuncks_per_answer = two_pow_folding_factor / 8; // "/ 8" because initial merkle leaves are in the basefield
    } else {
        n_chuncks_per_answer = two_pow_folding_factor * DIM / 8;
    }

    for i in 0..num_queries {
        new_fs_state, answer = fs_hint(fs_states_b[i], n_chuncks_per_answer); 
        fs_states_b[i + 1] = new_fs_state;
        answers[i] = answer;
    }
    fs_state_10 = fs_states_b[num_queries];

    leaf_hashes = malloc(num_queries); // a vector of vectorized pointers, each pointing to 1 chunk of 8 field elements
    for i in 0..num_queries {
        answer = answers[i];
        internal_states = malloc(1 + (n_chuncks_per_answer / 2)); // "/ 2" because with poseidon24 we hash 2 chuncks of 8 field elements at each permutation
        internal_states[0] = pointer_to_zero_vector; // initial state
        for j in 0..n_chuncks_per_answer / 2 {
            h24 = malloc_vec(1);
            poseidon24(answer + (2*j), internal_states[j], h24);
            internal_states[j + 1] = h24;
        }
        leaf_hashes[i] = internal_states[n_chuncks_per_answer / 2];
    }

    folded_domain_size = domain_size - folding_factor;

    fs_states_c = malloc(num_queries + 1);
    fs_states_c[0] = fs_state_10;

    for i in 0..num_queries {
        fs_state_11, merkle_path = fs_hint(fs_states_c[i], folded_domain_size);
        fs_states_c[i + 1] = fs_state_11;

        stir_index_bits = stir_challenges_indexes[i]; // a pointer to 31 bits

        states = malloc(1 + folded_domain_size);
        states[0] = leaf_hashes[i];
        for j in 0..folded_domain_size {
            if stir_index_bits[j] == 1 {
                left = merkle_path + j;
                right = states[j];
            } else {
                left = states[j];
                right = merkle_path + j;
            }
            state_j_plus_1 = malloc_vec(2);
            poseidon16(left, right, state_j_plus_1);
            states[j + 1] = state_j_plus_1;
        }
        assert_eq_vec(states[folded_domain_size], prev_root);
    }

    fs_state_11 = fs_states_c[num_queries];

    folds = malloc(num_queries * DIM);
    if merkle_leaves_in_basefield == 1 {
        folding_randomness_alligned = malloc_vec(1, log2_ceil(DIM * FOLDING_FACTOR_0));
        folding_randomness_alligned_ptr = folding_randomness_alligned * (2 ** log2_ceil(DIM * FOLDING_FACTOR_0));
        for i in 0..FOLDING_FACTOR_0 unroll {
            assert_eq_extension(folding_randomness + i*DIM, folding_randomness_alligned_ptr + i*DIM);
        }
        for i in 0..num_queries {
            res = malloc_vec(1);
            multilinear_eval((answers[i] * 8) / 2**FOLDING_FACTOR_0, folding_randomness_alligned, res, FOLDING_FACTOR_0); // TODO batching: use a single call to multilinear eval
            assert_eq_extension(res * 8, folds + i*DIM);
        }
    } else {
        poly_eq = poly_eq_extension(folding_randomness, folding_factor, two_pow_folding_factor);
        for i in 0..num_queries {
            dot_product_dynamic(answers[i] * 8, poly_eq, folds + i*DIM, two_pow_folding_factor);
        }
    }

    circle_values = malloc(num_queries); // ROOT^each_stir_index
    for i in 0..num_queries {
        stir_index_bits = stir_challenges_indexes[i];
        circle_value = unit_root_pow(folded_domain_size, stir_index_bits);
        circle_values[i] = circle_value;
    }

    return fs_state_11, circle_values, folds;
}


fn whir_round(fs_state, prev_root, folding_factor, two_pow_folding_factor, merkle_leaves_in_basefield, num_queries, domain_size, claimed_sum, grinding_bits) -> 7 {
    fs_state_7, folding_randomness, new_claimed_sum_a = sumcheck(fs_state, folding_factor, claimed_sum);

    fs_state_8, root, ood_point, ood_eval = parse_commitment(fs_state_7);

    fs_state_11, circle_values, folds = 
        sample_stir_indexes_and_fold(fs_state_8, num_queries, merkle_leaves_in_basefield, folding_factor, two_pow_folding_factor, domain_size, prev_root, folding_randomness, grinding_bits);

    fs_state_12, combination_randomness_gen = fs_sample_ef(fs_state_11);

    combination_randomness_powers = powers(combination_randomness_gen, num_queries + 1); // "+ 1" because of one OOD sample

    claimed_sum_supplement_side = malloc(5);
    dot_product_dynamic(folds, combination_randomness_powers + DIM, claimed_sum_supplement_side, num_queries);

    claimed_sum_supplement = add_extension_ret(claimed_sum_supplement_side, ood_eval);
    new_claimed_sum_b = add_extension_ret(claimed_sum_supplement, new_claimed_sum_a);

    return fs_state_12, folding_randomness, ood_point, root, circle_values, combination_randomness_powers, new_claimed_sum_b;
}

fn copy_chunk(src, dst) {
    // src: pointer to 8 F
    // dst: pointer to 8 F
    for i in 0..8 unroll { dst[i] = src[i]; }
    return;
}

fn copy_chunk_vec(src, dst) {
    zero = 0; // TODO
    add_extension(src, zero, dst);
    return;
}

fn powers(alpha, n) -> 1 {
    // alpha: EF
    // n: F

    res = malloc(n * DIM);
    set_to_one(res);
    for i in 0..n - 1 {
        mul_extension(res + i*DIM, alpha, res + (i + 1)*DIM);
    }
    return res;
}

fn unit_root_pow(domain_size, index_bits) -> 1 {
    // index_bits is a pointer to domain_size bits
    if domain_size == 19 {
        res = unit_root_pow_const(19, index_bits);
        return res;
    }
    if domain_size == 18 {
        res = unit_root_pow_const(18, index_bits);
        return res;
    }
    if domain_size == 17 {
        res = unit_root_pow_const(17, index_bits);
        return res;
    }
    if domain_size == 16 {
        res = unit_root_pow_const(16, index_bits);
        return res;
    }
    if domain_size == 15 {
        res = unit_root_pow_const(15, index_bits);
        return res;
    }
    if domain_size == 20 {
        res = unit_root_pow_const(20, index_bits);
        return res;
    }
    UNIMPLEMENTED = 0;
    print(UNIMPLEMENTED, domain_size);
    panic();
}

fn unit_root_pow_const(const domain_size, index_bits) -> 1 {
    prods = malloc(domain_size);
    prods[0] = ((index_bits[0] * ROOT**(2**(TWO_ADICITY - domain_size))) + (1 - index_bits[0]));
    for i in 1..domain_size unroll {
        prods[i] = prods[i - 1] * ((index_bits[i] * ROOT**(2**(TWO_ADICITY - domain_size + i))) + (1 - index_bits[i]));
    }
    return prods[domain_size - 1];
}

fn dot_product_dynamic(a, b, res, n) {
    if n == 16 {
        dot_product(a, b, res, 16);
        return;
    }
    if n == NUM_QUERIES_0 {
        dot_product(a, b, res, NUM_QUERIES_0);
        return;
    }
    if n == NUM_QUERIES_1 {
        dot_product(a, b, res, NUM_QUERIES_1);
        return;
    }
    if n == NUM_QUERIES_2 {
        dot_product(a, b, res, NUM_QUERIES_2);
        return;
    }
    if n == NUM_QUERIES_3 {
        dot_product(a, b, res, NUM_QUERIES_3);
        return;
    }
    if n == NUM_QUERIES_0 + 1 {
        dot_product(a, b, res, NUM_QUERIES_0 + 1);
        return;
    }
    if n == NUM_QUERIES_1 + 1 {
        dot_product(a, b, res, NUM_QUERIES_1 + 1);
        return;
    }
    if n == NUM_QUERIES_2 + 1 {
        dot_product(a, b, res, NUM_QUERIES_2 + 1);
        return;
    }
    if n == NUM_QUERIES_3 + 1 {
        dot_product(a, b, res, NUM_QUERIES_3 + 1);
        return;
    }

    TODO_dot_product_dynamic = 0;
    print(TODO_dot_product_dynamic, n);
    panic();
}

fn dot_product_base_extension(a, b, res, const n) {
    // a is a normal pointer to n F elements
    // b is a normal pointer to n continous EF elements
    // res is a normal pointer to 1 EF element

    prods = malloc(n * DIM);
    for i in 0..n unroll {
        for j in 0..DIM unroll {
            prods[i * DIM + j] = a[i] * b[i * DIM + j];
        }
    }
    my_buff = malloc(n * DIM);
    for i in 0..DIM unroll {
        my_buff[n * i] = prods[i];
        for j in 0..n - 1 unroll {
            my_buff[(n * i) + j + 1] = my_buff[(n * i) + j] + prods[i + ((j + 1) * DIM)];
        }
        res[i] = my_buff[(n * i) + n - 1];
    }

    return;
}

fn poly_eq_extension(point, n, two_pow_n) -> 1 {
    // Example: for n = 2: eq(x, y) = [(1 - x)(1 - y), (1 - x)y, x(1 - y), xy]

    if n == 0 {
        res = malloc(DIM);
        set_to_one(res);
        return res;
    }

    res = malloc(two_pow_n * DIM);

    inner_res = poly_eq_extension(point + DIM, n - 1, two_pow_n / 2);

    two_pow_n_minus_1 = two_pow_n / 2;

    for i in 0..two_pow_n_minus_1 {
        mul_extension(point, inner_res + i*DIM, res + (two_pow_n_minus_1 + i) * DIM);
        sub_extension(inner_res + i*DIM, res + (two_pow_n_minus_1 + i) * DIM, res + i*DIM);
    }
    
    return res;
}

fn poly_eq_base(point, n, two_pow_n) -> 1 {
    // return a (normal) pointer to 2^n base field elements, corresponding to the "equality polynomial" at point
    // Example: for n = 2: eq(x, y) = [(1 - x)(1 - y), (1 - x)y, x(1 - y), xy]

    if n == 0 {
        // base case
        res = malloc(1);
        res[0] = 1;
        return res;
    }

    res = malloc(two_pow_n);

    inner_res = poly_eq_base(point + 1, n - 1, two_pow_n / 2);

    two_pow_n_minus_1 = two_pow_n / 2;

    for i in 0..two_pow_n_minus_1 {
        res[two_pow_n_minus_1 + i] = inner_res[i] * point[0];
        res[i] = inner_res[i] - res[two_pow_n_minus_1 + i];
    }
    
    return res;
}


fn pow(a, b) -> 1 {
    if b == 0 {
        return 1; // a^0 = 1
    } else {
        p = pow(a, b - 1);
        return a * p;
    }
}

fn sample_bits(fs_state, n) -> 2 {
    // return the updated fs_state, and a pointer to n pointers, each pointing to 31 (boolean) field elements
    samples = malloc(n);
    new_fs_state = fs_sample_helper(fs_state, n, samples);
    sampled_bits = malloc(n);
    for i in 0..n {
        bits = checked_decompose_bits(samples[i]);
        sampled_bits[i] = bits;
    }

    return new_fs_state, sampled_bits;
}

fn checked_decompose_bits(a) -> 1 {
    // return a pointer to bits of a
    bits = decompose_bits(a); // hint

    for i in 0..F_BITS unroll {
        assert bits[i] * (1 - bits[i]) == 0;
    }
    sums = malloc(F_BITS);
    sums[0] = bits[0];
    for i in 1..F_BITS unroll {
        sums[i] = sums[i - 1] + bits[i] * 2**i;
    }
    assert a == sums[F_BITS - 1];
    return bits;
}

fn degree_two_polynomial_sum_at_0_and_1(coeffs) -> 1 {
    // coeffs is a normal pointer to 3 consecutive EF element
    // return a normal pointer to 1 ef element
    a = add_extension_ret(coeffs, coeffs);
    b = add_extension_ret(a, coeffs + DIM);
    c = add_extension_ret(b, coeffs + (DIM * 2));
    return c;
}

fn degree_two_polynomial_eval(coeffs, point) -> 1 {
    // coefs: normal pointer to 3 consecutive EF element
    // point: normal pointer to 1 EF element
    // return a normal pointer to 1 EF element
    point_squared = mul_extension_ret(point, point);
    a_xx = mul_extension_ret(coeffs + DIM * 2, point_squared);
    b_x = mul_extension_ret(coeffs + DIM, point);
    c = coeffs;
    res_0 = add_extension_ret(a_xx, b_x);
    res_1 = add_extension_ret(res_0, c);
    return res_1;
}

fn parse_commitment(fs_state) -> 4 {
    fs_state_1, root = fs_receive(fs_state, 1); // vectorized pointer of len 1
    fs_state_2, ood_point = fs_sample_ef(fs_state_1);
    fs_state_3, ood_eval = fs_receive_ef(fs_state_2, 1);
    return fs_state_3, root, ood_point, ood_eval;
}

// FIAT SHAMIR layout:
// 0 -> transcript (vectorized pointer)
// 1 -> vectorized pointer to first half of sponge state
// 2 -> vectorized pointer to second half of sponge state
// 3 -> output_buffer_size

fn fs_new(transcript) -> 1 {
    // transcript is a (vectorized) pointer
    // TODO domain separator
    fs_state = malloc(4);
    fs_state[0] = transcript;
    fs_state[1] = pointer_to_zero_vector; // first half of sponge state
    fs_state[2] = pointer_to_zero_vector; // second half of sponge state
    fs_state[3] = 0; // output buffer size

    return fs_state;
}

    fn fs_grinding(fs_state, bits) -> 1 {
    // WARNING: should not be called 2 times in a row without duplexing in between

    if bits == 0 {
        return fs_state; // no grinding
    }

    transcript_ptr = fs_state[0] * 8;
    l_ptr = fs_state[1] * 8;
    
    new_l = malloc_vec(1);
    new_l_ptr = new_l * 8;
    new_l_ptr[0] = transcript_ptr[0];
    for i in 1..8 unroll {
        new_l_ptr[i] = l_ptr[i];
    }

    l_r_updated = malloc_vec(2);
    poseidon16(new_l, fs_state[2], l_r_updated);
    new_fs_state = malloc(4);
    new_fs_state[0] = fs_state[0] + 1; // read one 1 chunk of 8 field elements (7 are useless)
    new_fs_state[1] = l_r_updated;
    new_fs_state[2] = l_r_updated + 1;
    new_fs_state[3] = 7; // output_buffer_size

    l_updated_ptr = l_r_updated* 8;
    sampled = l_updated_ptr[7];
    sampled_bits = checked_decompose_bits(sampled);
    for i in 0..bits {
        assert sampled_bits[i] == 0;
    }
    return new_fs_state;
}

fn less_than_8(a) inline -> 1 {
    if a * (a - 1) * (a - 2) * (a - 3) * (a - 4) * (a - 5) * (a - 6) * (a - 7) == 0 {
        return 1; // a < 8
    } else {
        return 0; // a >= 8
    }
}

fn fs_sample_ef(fs_state) -> 2 {
    // return the updated fs_state, and a normal pointer to 1 EF element
    res = malloc(DIM);
    new_fs_state = fs_sample_helper(fs_state, DIM, res);
    return new_fs_state, res;
}

fn fs_sample_helper(fs_state, n, res) -> 1 {
    // return the updated fs_state
    // fill res with n field elements

    output_buffer_size = fs_state[3];
    output_buffer_ptr = fs_state[1] * 8;

    for i in 0..n {
        if output_buffer_size - i == 0 {
            break;
        }
        res[i] = output_buffer_ptr[output_buffer_size - 1 - i];
    }

    finished = less_than_8(output_buffer_size - n);
    if finished == 1 {
        // no duplexing
        new_fs_state = malloc(4);
        new_fs_state[0] = fs_state[0];
        new_fs_state[1] = fs_state[1];
        new_fs_state[2] = fs_state[2];
        new_fs_state[3] = output_buffer_size - n;
        return new_fs_state;
    }

    // duplexing
    l_r = malloc_vec(2);
    poseidon16(fs_state[1], fs_state[2], l_r);
    new_fs_state = malloc(4);
    new_fs_state[0] = fs_state[0];
    new_fs_state[1] = l_r;
    new_fs_state[2] = l_r + 1;
    new_fs_state[3] = 8; // output_buffer_size

    remaining = n - output_buffer_size;
    if remaining == 0 {
        return new_fs_state;
    }

    shifted_res = res + output_buffer_size;
    final_res = fs_sample_helper(new_fs_state, remaining, shifted_res);
    return final_res;

}

fn fs_hint(fs_state, n) -> 2 {
    // return the updated fs_state, and a vectorized pointer to n chunk of 8 field elements

    res = fs_state[0];
    new_fs_state = malloc(4);
    new_fs_state[0] = res + n;
    new_fs_state[1] = fs_state[1];
    new_fs_state[2] = fs_state[2];
    new_fs_state[3] = fs_state[3];
    return new_fs_state, res; 
}

fn fs_receive_ef(fs_state, n) -> 2 {
    // return the updated fs_state, and a (normal) pointer to n consecutive EF elements
    final_fs_state = fs_observe(fs_state, n);
    res = malloc(n * DIM);
    // TODO optimize with dot_product
    for i in 0..n { // TODO unroll in most cases
        ptr = (fs_state[0] + i) * 8;
        for j in 0..DIM unroll {
            res[i * DIM + j] = ptr[j];
        }
        for j in DIM..8 unroll {
            assert ptr[j] == 0;
        }
    }

    return final_fs_state, res;
}

fn fs_receive(fs_state, n) -> 2 {
    // return the updated fs_state, and a vectorized pointer to n chunk of 8 field elements

    res = fs_state[0];
    final_fs_state = fs_observe(fs_state, n);
    return final_fs_state, res;
}

fn fs_observe(fs_state, n) -> 1 {
    // observe n chunk of 8 field elements from the transcript
    // and return the updated fs_state
    // duplexing
    l_r = malloc_vec(2);
    poseidon16(fs_state[0], fs_state[2], l_r);
    new_fs_state = malloc(4);
    new_fs_state[0] = fs_state[0] + 1;
    new_fs_state[1] = l_r;
    new_fs_state[2] = l_r + 1;
    new_fs_state[3] = 8; // output_buffer_size

    if n == 1 {
        return new_fs_state;
    } else {
        final_fs_state = fs_observe(new_fs_state, n - 1);
        return final_fs_state;
    }
}

fn fs_print_state(fs_state) {
    left = fs_state[1] * 8;
    for i in 0..8 {
        print(left[i]);
    }
    right = fs_state[2] * 8;
    for i in 0..8 {
        print(right[i]);
    }
    return;
}

fn mul_extension_ret(a, b) inline -> 1 {
    c = malloc(DIM);
    dot_product(a, b, c, 1);
    return c;
}

fn mul_extension(a, b, c) inline {
    dot_product(a, b, c, 1);
    return;
}

fn add_extension_ret(a, b) inline -> 1 {
    // TODO if a and b are adjacent we can do it in one cycle using the dot_product precompile
    c = malloc(DIM);
    for i in 0..DIM unroll {
        c[i] = a[i] + b[i];
    }
    return c;
}

fn add_extension(a, b, c) inline {
    // TODO if a and b are adjacent we can do it in one cycle using the dot_product precompile
    for i in 0..DIM unroll {
        c[i] = a[i] + b[i];
    }
    return;
}

fn sub_extension(a, b, c) inline {
    // TODO if a and b are adjacent we can do it in one cycle using the dot_product precompile
    for i in 0..DIM unroll {
        c[i] = a[i] - b[i];
    }
    return;
}

fn assert_eq_extension(a, b) inline {
    dot_product(a, pointer_to_one_vector * 8, b, 1);
    return;
}

// TODO improve
fn assert_eq_vec(a, b) inline {
    a_ptr = a * 8;
    b_ptr = b * 8;
    dot_product(a_ptr, pointer_to_one_vector * 8, b_ptr, 1);
    dot_product(a_ptr + (8 - DIM), pointer_to_one_vector * 8, b_ptr + (8 - DIM), 1);
    return;
}

fn set_to_one(a) inline {
    a[0] = 1;
    for i in 1..DIM unroll { a[i] = 0; }
    return;
}

fn print_vec(a) {
    print_many_vec(a, 1);
    return;
}

fn print_many_vec(a, n) {
    print_many(a * 8, n * 8);
    return;
}

fn print_many(a, n) {
    for i in 0..n {
        print(a[i]);
    }
    return;
}

fn next_multiple_of_8(const a) -> 1 {
    return a + (8 - (a % 8)) % 8;
}

