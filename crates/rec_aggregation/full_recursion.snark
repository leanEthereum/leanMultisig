const COMPRESSION = 1;
const PERMUTATION = 0;

const F_BITS = 31; // koala-bear = 31 bits
const DIM = 5; // extension degree

const N_VARS = N_VARS_PLACEHOLDER;
const LOG_INV_RATE = LOG_INV_RATE_PLACEHOLDER; 
const N_ROUNDS = 3; // TODO make it a parameter

const FOLDING_FACTOR_0 = FOLDING_FACTOR_0_PLACEHOLDER;
const FOLDING_FACTOR_1 = FOLDING_FACTOR_1_PLACEHOLDER;
const FOLDING_FACTOR_2 = FOLDING_FACTOR_2_PLACEHOLDER;
const FOLDING_FACTOR_3 = FOLDING_FACTOR_3_PLACEHOLDER;

const FINAL_VARS = N_VARS - (FOLDING_FACTOR_0 + FOLDING_FACTOR_1 + FOLDING_FACTOR_2 + FOLDING_FACTOR_3);

const RS_REDUCTION_FACTOR_0 = RS_REDUCTION_FACTOR_0_PLACEHOLDER;
const RS_REDUCTION_FACTOR_1 = 1;
const RS_REDUCTION_FACTOR_2 = 1;
const RS_REDUCTION_FACTOR_3 = 1;

const NUM_OOD_COMMIT = NUM_OOD_COMMIT_PLACEHOLDER;
const NUM_OOD_0 = NUM_OOD_0_PLACEHOLDER;
const NUM_OOD_1 = NUM_OOD_1_PLACEHOLDER;
const NUM_OOD_2 = NUM_OOD_2_PLACEHOLDER;

const NUM_QUERIES_0 = NUM_QUERIES_0_PLACEHOLDER;
const NUM_QUERIES_1 = NUM_QUERIES_1_PLACEHOLDER;
const NUM_QUERIES_2 = NUM_QUERIES_2_PLACEHOLDER;
const NUM_QUERIES_3 = NUM_QUERIES_3_PLACEHOLDER;

const GRINDING_BITS_0 = GRINDING_BITS_0_PLACEHOLDER;
const GRINDING_BITS_1 = GRINDING_BITS_1_PLACEHOLDER;
const GRINDING_BITS_2 = GRINDING_BITS_2_PLACEHOLDER;
const GRINDING_BITS_3 = GRINDING_BITS_3_PLACEHOLDER;

const MERKLE_HEIGHT_0 = N_VARS + LOG_INV_RATE - FOLDING_FACTOR_0;
const MERKLE_HEIGHT_1 = N_VARS + LOG_INV_RATE - FOLDING_FACTOR_1 - RS_REDUCTION_FACTOR_0;
const MERKLE_HEIGHT_2 = MERKLE_HEIGHT_1 - RS_REDUCTION_FACTOR_1;
const MERKLE_HEIGHT_3 = MERKLE_HEIGHT_2 - RS_REDUCTION_FACTOR_2;

const TWO_ADICITY = 24;
const ROOT = 1791270792; // of order 2^TWO_ADICITY

const VECTOR_LEN = 8;

const N_TABLES = N_TABLES_PLACEHOLDER;

fn main() {
    proof_transcript = private_input_start();
    fs_1 = fs_new(proof_transcript);

    // table dims
    debug_assert N_TABLES + 1 < VECTOR_LEN;
    mem_and_table_dims = fs_1[16];
    non_zero_memory_size = mem_and_table_dims[0];
    table_dims = mem_and_table_dims + 1;

    return;
}

fn eq_mle_extension(a, b, n) -> 1 {

    buff = malloc(n*DIM);

    for i in 0..n {
        shift = i * DIM;
        ai = a + shift;
        bi = b + shift;
        buffi = buff + shift;
        ab = mul_extension_ret(ai, bi);
        buffi[0] = 1 + 2 * ab[0] - ai[0] - bi[0];
        for j in 1..DIM unroll {
            buffi[j] = 2 * ab[j] - ai[j] - bi[j];
        }
    }

    prods = malloc(n*DIM);
    copy_5(buff, prods);
    for i in 0..n - 1 {
        mul_extension(prods + i*DIM, buff + (i + 1)*DIM, prods + (i + 1)*DIM);
    }

    return prods + (n - 1) * DIM;
}

fn eq_mle_extension_base_const(a, b, const n) -> 1 {
    // a: base
    // b: extension

    buff = malloc(n*DIM);

    for i in 0..n unroll {
        ai = a[i];
        bi = b + i*DIM;
        buffi = buff + i*DIM;
        ai_double = ai * 2;
        buffi[0] = 1 + ai_double * bi[0] - ai - bi[0];
        for j in 1..DIM unroll {
            buffi[j] = ai_double * bi[j] - bi[j];
        }
    }

    prods = malloc(n*DIM);
    copy_5(buff, prods);
    for i in 0..n - 1 unroll {
        mul_extension(prods + i*DIM, buff + (i + 1)*DIM, prods + (i + 1)*DIM);
    }
    return prods + (n - 1) * DIM;
}

fn sumcheck(fs_state, n_steps, claimed_sum) -> 3 {

    fs_states_a = malloc(n_steps + 1);
    fs_states_a[0] = fs_state;

    claimed_sums = malloc(n_steps + 1);
    claimed_sums[0] = claimed_sum;

    folding_randomness = malloc(n_steps * DIM);

    for sc_round in 0..n_steps {
        fs_5, poly = fs_receive_ef(fs_states_a[sc_round], 3);
        sum_over_boolean_hypercube = degree_two_polynomial_sum_at_0_and_1(poly);
        copy_5(sum_over_boolean_hypercube, claimed_sums[sc_round]);
        fs_6, rand = fs_sample_ef(fs_5);
        fs_states_a[sc_round + 1] = fs_6;
        new_claimed_sum = degree_two_polynomial_eval(poly, rand);
        claimed_sums[sc_round + 1] = new_claimed_sum;
        copy_5(rand, folding_randomness + sc_round * DIM);
    }

    new_state = fs_states_a[n_steps];
    new_claimed_sum = claimed_sums[n_steps];

    return new_state, folding_randomness, new_claimed_sum;
}


fn dot_product_ee_dynamic(a, b, res, n) { 
    if n == 16 {
        dot_product_ee(a, b, res, 16);
        return;
    }
    if n == 1 {
        dot_product_ee(a, b, res, 1);
        return;
    }
    if n == 2 {
        dot_product_ee(a, b, res, 2);
        return;
    }

    dot_product_ee_dynamic_helper_1(a, b, res, n);
    return;
}

fn dot_product_ee_dynamic_helper_1(a, b, res, n) {
    if n == NUM_QUERIES_0 {
        dot_product_ee(a, b, res, NUM_QUERIES_0);
        return;
    }

    dot_product_ee_dynamic_helper_2(a, b, res, n);
    return;
}

fn dot_product_ee_dynamic_helper_2(a, b, res, n) {
    if n == NUM_QUERIES_1 {
        dot_product_ee(a, b, res, NUM_QUERIES_1);
        return;
    }
    if n == NUM_QUERIES_2 {
        dot_product_ee(a, b, res, NUM_QUERIES_2);
        return;
    }

    dot_product_ee_dynamic_helper_3(a, b, res, n);
    return;
}

fn dot_product_ee_dynamic_helper_3(a, b, res, n) {
    if n == NUM_QUERIES_3 {
        dot_product_ee(a, b, res, NUM_QUERIES_3);
        return;
    }
    if n == NUM_QUERIES_0 + 1 {
        dot_product_ee(a, b, res, NUM_QUERIES_0 + 1);
        return;
    }

    dot_product_ee_dynamic_helper_4(a, b, res, n);
    return;
}

fn dot_product_ee_dynamic_helper_4(a, b, res, n) {
    if n == NUM_QUERIES_1 + 1 {
        dot_product_ee(a, b, res, NUM_QUERIES_1 + 1);
        return;
    }
    if n == NUM_QUERIES_2 + 1 {
        dot_product_ee(a, b, res, NUM_QUERIES_2 + 1);
        return;
    }

    dot_product_ee_dynamic_helper_5(a, b, res, n);
    return;
}

fn dot_product_ee_dynamic_helper_5(a, b, res, n) {
    if n == NUM_QUERIES_3 + 1 {
        dot_product_ee(a, b, res, NUM_QUERIES_3 + 1);
        return;
    }

    TODO_dot_product_ee_dynamic = 0;
    print(TODO_dot_product_ee_dynamic, n);
    panic();
}

fn poly_eq_extension(point, n, two_pow_n) -> 1 {
    // Example: for n = 2: eq(x, y) = [(1 - x)(1 - y), (1 - x)y, x(1 - y), xy]

    if n == 0 {
        res = malloc(DIM);
        set_to_one(res);
        return res;
    } else {
        res = malloc(two_pow_n * DIM);

        inner_res = poly_eq_extension(point + DIM, n - 1, two_pow_n / 2);

        two_pow_n_minus_1 = two_pow_n / 2;

        for i in 0..two_pow_n_minus_1 {
            mul_extension(point, inner_res + i*DIM, res + (two_pow_n_minus_1 + i) * DIM);
            sub_extension(inner_res + i*DIM, res + (two_pow_n_minus_1 + i) * DIM, res + i*DIM);
        }
        
        return res;
    }
}

fn pow(a, b) -> 1 {
    if b == 0 {
        return 1; // a^0 = 1
    } else {
        p = pow(a, b - 1);
        return a * p;
    }
}

fn degree_two_polynomial_sum_at_0_and_1(coeffs) -> 1 {
    // coeffs is a normal pointer to 3 consecutive EF element
    // return a normal pointer to 1 ef element
    a = add_extension_ret(coeffs, coeffs);
    b = add_extension_ret(a, coeffs + DIM);
    c = add_extension_ret(b, coeffs + (DIM * 2));
    return c;
}

fn degree_two_polynomial_eval(coeffs, point) -> 1 {
    // coefs: normal pointer to 3 consecutive EF element
    // point: normal pointer to 1 EF element
    // return a normal pointer to 1 EF element
    point_squared = mul_extension_ret(point, point);
    a_xx = mul_extension_ret(coeffs + DIM * 2, point_squared);
    b_x = mul_extension_ret(coeffs + DIM, point);
    c = coeffs;
    res_0 = add_extension_ret(a_xx, b_x);
    res_1 = add_extension_ret(res_0, c);
    return res_1;
}

fn parse_whir_commitment_const(fs_state, const num_ood) -> 4 {
    fs_1, root = fs_receive_chunks(fs_state, 1);
    ood_points = malloc(num_ood * DIM);
    all_fs = malloc(num_ood + 1);
    all_fs[0] = fs_1;
    for i in 0..num_ood unroll {
        next_fs, ood_point = fs_sample_ef(all_fs[i]);
        copy_5(ood_point, ood_points + i * DIM);
        duplexed = duplexing(next_fs);
        all_fs[i + 1] = duplexed;
    }
    fs_4, ood_evals = fs_receive_ef(all_fs[num_ood], num_ood);
    return fs_4, root, ood_points, ood_evals;
}

// FIAT SHAMIR layout: 17 field elements
// 0..8 -> first half of sponge state
// 8..16 -> second half of sponge state
// 16 -> transcript pointer

fn fs_new(transcript_ptr) -> 1 {
    fs_state = malloc(17);
    set_to_16_zeros(fs_state);
    fs_state[16] = transcript_ptr;
    duplexed = duplexing(fs_state);
    return duplexed;
}

fn duplexing(fs) -> 1 {
    new_fs = malloc(17);
    poseidon16(fs, fs + 8, new_fs, PERMUTATION);
    new_fs[16] = fs[16];
    return new_fs;
}

fn fs_sample_ef(fs) -> 2 {
    return fs, fs;
}

fn fs_hint(fs, n) -> 2 {
    // return the updated fiat-shamir, and a pointer to n field elements from the transcript

    transcript_ptr = fs[16];
    new_fs = malloc(17);
    copy_16(fs, new_fs);
    new_fs[16] = fs[16] + n; // advance transcript pointer
    return new_fs, transcript_ptr;
}

fn fs_receive_chunks(fs, const n_chunks) -> 2 {
    // each chunk = 8 field elements
    new_fs = malloc(1 + 16 * n_chunks);
    transcript_ptr = fs[16];
    new_fs[16 * n_chunks] = transcript_ptr + 8 * n_chunks; // advance transcript pointer

    poseidon16(transcript_ptr, fs + 8, new_fs, PERMUTATION);
    for i in 1..n_chunks unroll {
        poseidon16(transcript_ptr + i * 8, new_fs + ((i-1) * 16 + 8), new_fs + i * 16, PERMUTATION);
    }
    return new_fs + 16 * (n_chunks - 1), transcript_ptr;
}

fn fs_receive_ef(fs, const n) -> 2 {
    new_fs, ef_ptr = fs_receive_chunks(fs, next_multiple_of(n * DIM, 8) / 8);
    for i in n * DIM..next_multiple_of(n * DIM, 8) unroll {
        assert ef_ptr[i] == 0;
    }
    return new_fs, ef_ptr;
}


fn fs_print_state(fs_state) {
    for i in 0..17 unroll {
        print(i, fs_state[i]);
    }
    return;
}

fn mul_extension_ret(a, b) inline -> 1 {
    c = malloc(DIM);
    dot_product_ee(a, b, c, 1);
    return c;
}

fn mul_extension(a, b, c) inline {
    dot_product_ee(a, b, c, 1);
    return;
}

fn add_extension_ret(a, b) inline -> 1 {
    // TODO if a and b are adjacent we can do it in one cycle using the dot_product precompile
    c = malloc(DIM);
    for i in 0..DIM unroll {
        c[i] = a[i] + b[i];
    }
    return c;
}

fn add_extension(a, b, c) inline {
    // TODO if a and b are adjacent we can do it in one cycle using the dot_product precompile
    for i in 0..DIM unroll {
        c[i] = a[i] + b[i];
    }
    return;
}

fn sub_extension(a, b, c) inline {
    // TODO if a and b are adjacent we can do it in one cycle using the dot_product precompile
    for i in 0..DIM unroll {
        c[i] = a[i] - b[i];
    }
    return;
}

fn copy_5(a, b) inline {
    dot_product_ee(a, pointer_to_one_vector, b, 1);
    return;
}

fn set_to_5_zeros(a) inline {
    zero_ptr = pointer_to_zero_vector;
    dot_product_ee(a, pointer_to_one_vector, zero_ptr, 1);
    return;
}

fn set_to_7_zeros(a) inline {
    zero_ptr = pointer_to_zero_vector;
    dot_product_ee(a, pointer_to_one_vector, zero_ptr, 1);
    a[5] = 0;
    a[6] = 0;
    return;
}

fn set_to_16_zeros(a) inline {
    zero_ptr = pointer_to_zero_vector;
    dot_product_ee(a, pointer_to_one_vector, zero_ptr, 1);
    dot_product_ee(a + 5, pointer_to_one_vector, zero_ptr, 1);
    dot_product_ee(a + 10, pointer_to_one_vector, zero_ptr, 1);
    a[15] = 0;
    return;
}

fn copy_8(a, b) inline {
    dot_product_ee(a, pointer_to_one_vector, b, 1);
    assert a[5] == b[5];
    assert a[6] == b[6];
    assert a[7] == b[7];
    return;
}

fn copy_16(a, b) inline {
    dot_product_ee(a, pointer_to_one_vector, b, 1);
    dot_product_ee(a + 5, pointer_to_one_vector, b + 5, 1);
    dot_product_ee(a + 10, pointer_to_one_vector, b + 10, 1);
    a[15] = b[15];
    return;
}

fn set_to_one(a) inline {
    a[0] = 1;
    for i in 1..DIM unroll { a[i] = 0; }
    return;
}


fn print_ef(a) {
    for i in 0..DIM unroll {
        print(a[i]);
    }
    return;
}

fn print_vec(a) {
    for i in 0..VECTOR_LEN unroll {
        print(a[i]);
    }
    return;
}

fn print_many(a, n) {
    for i in 0..n {
        print(a[i]);
    }
    return;
}

fn next_multiple_of_8(const a) -> 1 {
    return a + (8 - (a % 8)) % 8;
}

fn read_memory(ptr) inline -> 1  {
    mem = 0;
    return mem[ptr];
}

fn range_check(a, b) inline {
    // TODO (for now we simulate the cost)
    dummy1 = a + b;
    dummy2 = dummy1 * a;
    dummy3 = dummy2 + b;
    return;
}