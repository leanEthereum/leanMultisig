import "whir_core.snark";

const N_TABLES = N_TABLES_PLACEHOLDER;
const MIN_LOG_N_ROWS_PER_TABLE = MIN_LOG_N_ROWS_PER_TABLE_PLACEHOLDER;
const MAX_LOG_N_ROWS_PER_TABLE = MAX_LOG_N_ROWS_PER_TABLE_PLACEHOLDER;
const MIN_LOG_MEMORY_SIZE = MIN_LOG_MEMORY_SIZE_PLACEHOLDER;
const MAX_LOG_MEMORY_SIZE = MAX_LOG_MEMORY_SIZE_PLACEHOLDER;
const N_VARS_FIRST_GKR = N_VARS_FIRST_GKR_PLACEHOLDER;
const MAX_BUS_WIDTH = MAX_BUS_WIDTH_PLACEHOLDER;
const MEMORY_TABLE_INDEX = MEMORY_TABLE_INDEX_PLACEHOLDER;
const UNIVARIATE_SKIPS = UNIVARIATE_SKIPS_PLACEHOLDER;

fn main() {
    proof_transcript = private_input_start();
    fs_1 = fs_new(proof_transcript);

    // table dims
    debug_assert N_TABLES + 1 < VECTOR_LEN; // (because duplex only once bellow)
    fs_2, mem_and_table_dims = fs_receive_chunks(fs_1, 1);
    for i in N_TABLES + 1..8 unroll {
        assert mem_and_table_dims[i] == 0;
    }
    log_memory = mem_and_table_dims[0];
    table_dims = mem_and_table_dims + 1;

    for i in 0..N_TABLES unroll {
        n_vars_for_table = table_dims[i];
        range_check(n_vars_for_table, log_memory + 1);
        full_range_check(MIN_LOG_N_ROWS_PER_TABLE - 1, n_vars_for_table, MAX_LOG_N_ROWS_PER_TABLE + 1);
    }
    full_range_check(MIN_LOG_MEMORY_SIZE - 1, log_memory, MAX_LOG_MEMORY_SIZE + 1);

    // parse 1st whir commitment
    fs_3, whir_base_root, whir_base_ood_points, whir_base_ood_evals = parse_whir_commitment_const(fs_2, NUM_OOD_COMMIT);

    fs_5, logup_c = fs_sample_ef(fs_3);
    fs_6 = duplexing(logup_c);
    fs_7, logup_alpha = fs_sample_ef(fs_6);
    fs_8 = duplexing(logup_alpha);

    // verify_generic_logup

    fs9, quotient_gkr, point_gkr, claims_num, claims_den = verify_gkr_quotient(fs_8, N_VARS_FIRST_GKR);
    set_to_5_zeros(quotient_gkr);

    alpha_powers = powers(logup_alpha, MAX_BUS_WIDTH);

    retrieved_numerators_value = malloc(100); // TODO proper size
    retrieved_denominators_value = malloc(100); // TODO proper size

    memory_and_acc_prefix = multilinear_location_prefix(0, N_VARS_FIRST_GKR - log_memory, point_gkr);

    fs10, value_acc = fs_receive_ef(fs9, 1);
    fs11, value_memory = fs_receive_ef(fs10, 1);

    pref_mul_value_acc = mul_extension_ret(memory_and_acc_prefix, value_acc);
    retrieved_numerators_value[0] = opposite_extension_ret(pref_mul_value_acc);

    value_index = mle_of_01234567_etc(point_gkr + (N_VARS_FIRST_GKR - log_memory) * DIM, log_memory);
    fingerprint_memory = fingerprint_2(MEMORY_TABLE_INDEX, value_index, value_memory, alpha_powers);
    c_minus_fingerprint_memory = sub_extension_ret(logup_c, fingerprint_memory);
    retrieved_denominators_value[0] = mul_extension_ret(memory_and_acc_prefix, c_minus_fingerprint_memory);

    all_fs = malloc(100); // TODO proper size
    all_offsets = malloc(100); // TODO proper size
    all_fs[0] = fs11;
    all_offsets[0] = powers_of_two(log_memory);
    for table_index in 0..N_TABLES unroll {
        log_n_rows = table_dims[table_index];
        n_rows = powers_of_two(log_n_rows);
        offset = all_offsets[table_index];
        inner_point = point_gkr + (N_VARS_FIRST_GKR - log_n_rows) * DIM;
        
        prefix = multilinear_location_prefix(offset / n_rows, N_VARS_FIRST_GKR - log_n_rows, point_gkr);
        poly_eq_missing_inner_point = poly_eq_extension(inner_point, UNIVARIATE_SKIPS);

        fs_a1, evals_on_selector = fs_receive_ef(all_fs[table_index], 2**UNIVARIATE_SKIPS);
        evals_on_selector_ml_eval = malloc(DIM);
        dot_product(evals_on_selector, poly_eq_missing_inner_point, evals_on_selector_ml_eval, 2**UNIVARIATE_SKIPS, EE);
        retrieved_numerators_value_new_term = mul_extension_ret(prefix, evals_on_selector_ml_eval);
        retrieved_numerators_value[table_index + 1] = add_extension_ret(retrieved_numerators_value[table_index], retrieved_numerators_value_new_term);
        
        fs_a2, evals_on_data = fs_receive_ef(fs_a1, 2**UNIVARIATE_SKIPS);
        evals_on_data_ml_eval = malloc(DIM);
        dot_product(evals_on_data, poly_eq_missing_inner_point, evals_on_data_ml_eval, 2**UNIVARIATE_SKIPS, EE);
        retrieved_denominators_value_new_term = mul_extension_ret(prefix, evals_on_data_ml_eval);
        retrieved_denominators_value[table_index + 1] = add_extension_ret(retrieved_denominators_value[table_index], retrieved_denominators_value_new_term);

        
        all_fs[table_index + 1] = fs_a2; // TODO

        return;
    }

    return;
}

fn multilinear_location_prefix(offset, n_vars, point) -> 1 {
    bits = checked_decompose_bits_small_value(offset, n_vars);
    res = eq_mle_extension_base(bits, point, n_vars);
    return res;
}

fn fingerprint_2(table_index, data_1, data_2, alpha_powers) -> 1 {
    res1 = mul_extension_ret(data_1, alpha_powers + DIM);
    res2 = mul_extension_ret(data_2, alpha_powers + 2 * DIM);
    res3 = add_extension_ret(res1, res2);
    res4 = add_base_extension_ret(table_index, res3);
    return res4;
}

fn verify_gkr_quotient(fs, n_vars) -> 5 {
    fs1, nums = fs_receive_ef(fs, 2);
    fs4, denoms = fs_receive_ef(fs1, 2);

    q1 = div_extension(nums, denoms);
    q2 = div_extension(nums + DIM, denoms + DIM);
    quotient = add_extension_ret(q1, q2);

    points = malloc(n_vars);
    claims_num = malloc(n_vars);
    claims_den = malloc(n_vars);

    fs5, points[0] = fs_sample_ef(fs4);
    fs6 = duplexing(fs5);

    point_poly_eq = poly_eq_extension(points[0], 1);

    first_claim_num = malloc(DIM);
    first_claim_den = malloc(DIM);
    dot_product(nums, point_poly_eq, first_claim_num, 2, EE);
    dot_product(denoms, point_poly_eq, first_claim_den, 2, EE);
    claims_num[0] = first_claim_num;
    claims_den[0] = first_claim_den;

    all_fs = malloc(n_vars);
    all_fs[0] = fs6;
    for i in 1..n_vars {
        all_fs[i], points[i], claims_num[i], claims_den[i] = verify_gkr_quotient_step(all_fs[i - 1], i, points[i - 1], claims_num[i - 1], claims_den[i - 1]);
    }
    
    return all_fs[n_vars - 1], quotient, points[n_vars - 1], claims_num[n_vars - 1], claims_den[n_vars - 1];
}

fn verify_gkr_quotient_step(fs, n_vars, point, claim_num, claim_den) -> 4 {
    fs1, alpha = fs_sample_ef(fs);
    alpha_mul_claim_den = mul_extension_ret(alpha, claim_den);
    num_plus_alpha_mul_claim_den = add_extension_ret(claim_num, alpha_mul_claim_den);
    postponed_point = malloc((n_vars + 1) * DIM);
    fs2, postponed_value = sumcheck_verify_helper(fs1, n_vars, num_plus_alpha_mul_claim_den, 3, postponed_point + DIM);
    fs3, inner_evals = fs_receive_ef(fs2, 4);
    a_num = inner_evals;
    b_num = inner_evals + DIM;
    a_den = inner_evals + 2 * DIM;
    b_den = inner_evals + 3 * DIM;
    sum_num, sum_den = sum_2_ef_fractions(a_num, a_den, b_num, b_den);
    sum_den_mul_alpha = mul_extension_ret(sum_den, alpha);
    sum_num_plus_sum_den_mul_alpha = add_extension_ret(sum_num, sum_den_mul_alpha);
    eq_factor = eq_mle_extension(point, postponed_point + DIM, n_vars);
    mul_extension(sum_num_plus_sum_den_mul_alpha, eq_factor, postponed_value);
    
    fs4, beta = fs_sample_ef(fs3);
    fs5 = duplexing(fs4);
    point_poly_eq = poly_eq_extension(beta, 1);
    new_claim_num = malloc(DIM);
    new_claim_den = malloc(DIM);
    dot_product(inner_evals, point_poly_eq, new_claim_num, 2, EE);
    dot_product(inner_evals + 2 * DIM, point_poly_eq, new_claim_den, 2, EE);

    copy_5(beta, postponed_point);

    return fs5, postponed_point, new_claim_num, new_claim_den;
    
}
