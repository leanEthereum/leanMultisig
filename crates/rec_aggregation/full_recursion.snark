import "whir_core.snark";

const N_TABLES = N_TABLES_PLACEHOLDER;
const MIN_LOG_N_ROWS_PER_TABLE = MIN_LOG_N_ROWS_PER_TABLE_PLACEHOLDER;
const MAX_LOG_N_ROWS_PER_TABLE = MAX_LOG_N_ROWS_PER_TABLE_PLACEHOLDER;
const MIN_LOG_MEMORY_SIZE = MIN_LOG_MEMORY_SIZE_PLACEHOLDER;
const MAX_LOG_MEMORY_SIZE = MAX_LOG_MEMORY_SIZE_PLACEHOLDER;
const N_VARS_FIRST_GKR = N_VARS_FIRST_GKR_PLACEHOLDER;
const MAX_BUS_WIDTH = MAX_BUS_WIDTH_PLACEHOLDER;
const MEMORY_TABLE_INDEX = MEMORY_TABLE_INDEX_PLACEHOLDER;
const UNIVARIATE_SKIPS = UNIVARIATE_SKIPS_PLACEHOLDER;
const LOOKUPS_F_INDEXES = LOOKUPS_F_INDEXES_PLACEHOLDER;
const LOOKUPS_F_VALUES = LOOKUPS_F_VALUES_PLACEHOLDER;
const NUM_COLS_F_AIR = NUM_COLS_F_AIR_PLACEHOLDER;
const NUM_COLS_EF_AIR = NUM_COLS_EF_AIR_PLACEHOLDER;

fn main() {
    proof_transcript = private_input_start();
    mut fs = fs_new(proof_transcript);

    // table dims
    debug_assert N_TABLES + 1 < VECTOR_LEN; // (because duplex only once bellow)
    fs, mem_and_table_dims = fs_receive_chunks(fs, 1);
    for i in N_TABLES + 1..8 unroll {
        assert mem_and_table_dims[i] == 0;
    }
    log_memory = mem_and_table_dims[0];
    table_dims = mem_and_table_dims + 1;

    for i in 0..N_TABLES unroll {
        n_vars_for_table = table_dims[i];
        range_check(n_vars_for_table, log_memory + 1);
        full_range_check(MIN_LOG_N_ROWS_PER_TABLE - 1, n_vars_for_table, MAX_LOG_N_ROWS_PER_TABLE + 1);
    }
    full_range_check(MIN_LOG_MEMORY_SIZE - 1, log_memory, MAX_LOG_MEMORY_SIZE + 1);

    // parse 1st whir commitment
    fs, whir_base_root, whir_base_ood_points, whir_base_ood_evals = parse_whir_commitment_const(fs, NUM_OOD_COMMIT);

    logup_c = fs_sample_ef(fs);
    fs = duplexing(fs);
    logup_alpha = fs_sample_ef(fs);
    fs = duplexing(fs);

    // verify_generic_logup

    fs, quotient_gkr, point_gkr, claims_num, claims_den = verify_gkr_quotient(fs, N_VARS_FIRST_GKR);
    set_to_5_zeros(quotient_gkr);

    alpha_powers = powers(logup_alpha, MAX_BUS_WIDTH);

    memory_and_acc_prefix = multilinear_location_prefix(0, N_VARS_FIRST_GKR - log_memory, point_gkr);

    fs, value_acc = fs_receive_ef(fs, 1);
    fs, value_memory = fs_receive_ef(fs, 1);

    mut retrieved_numerators_value = opposite_extension_ret(mul_extension_ret(memory_and_acc_prefix, value_acc));

    value_index = mle_of_01234567_etc(point_gkr + (N_VARS_FIRST_GKR - log_memory) * DIM, log_memory);
    fingerprint_memory = fingerprint_2(MEMORY_TABLE_INDEX, value_index, value_memory, alpha_powers);
    mut retrieved_denominators_value = mul_extension_ret(memory_and_acc_prefix, sub_extension_ret(logup_c, fingerprint_memory));

    mut offset = powers_of_two(log_memory);
    all_bus_statements_points = vec![];
    all_bus_statements_numerators_claims = vec![];
    all_bus_statements_denominators_claims = vec![];
    columns_values = vec![];
    for table_index in 0..N_TABLES unroll {
        // I] Bus (data flow between tables)

        log_n_rows = table_dims[table_index];
        n_rows = powers_of_two(log_n_rows);
        inner_point = point_gkr + (N_VARS_FIRST_GKR - log_n_rows) * DIM;
        inner_inner_point = inner_point + DIM * UNIVARIATE_SKIPS;

        prefix = multilinear_location_prefix(offset / n_rows, N_VARS_FIRST_GKR - log_n_rows, point_gkr);
        poly_eq_missing_inner_point = poly_eq_extension(inner_point, UNIVARIATE_SKIPS);

        fs, evals_on_selector = fs_receive_ef(fs, 2**UNIVARIATE_SKIPS);
        evals_on_selector_ml_eval = dot_product_ret(evals_on_selector, poly_eq_missing_inner_point, 2**UNIVARIATE_SKIPS, EE);
        retrieved_numerators_value = add_extension_ret(retrieved_numerators_value, mul_extension_ret(prefix, evals_on_selector_ml_eval));

        fs, evals_on_data = fs_receive_ef(fs, 2**UNIVARIATE_SKIPS);
        evals_on_data_ml_eval = dot_product_ret(evals_on_data, poly_eq_missing_inner_point, 2**UNIVARIATE_SKIPS, EE);
        retrieved_denominators_value = add_extension_ret(retrieved_denominators_value, mul_extension_ret(prefix, evals_on_data_ml_eval));

        gamma = fs_sample_ef(fs);
        fs = duplexing(fs);

        bus_point = malloc((log_n_rows - UNIVARIATE_SKIPS + 1) * DIM);
        copy_5(gamma, bus_point);
        copy_many_ef(inner_inner_point, bus_point + DIM, log_n_rows - UNIVARIATE_SKIPS);
        all_bus_statements_points.push(bus_point);

        unvariate_selectors_evals = eval_all_univariate_selectors(gamma);

        univariate_value_on_selectors = dot_product_ret(evals_on_selector, unvariate_selectors_evals, 2**UNIVARIATE_SKIPS, EE);
        all_bus_statements_numerators_claims.push(univariate_value_on_selectors);

        univariate_value_on_data = dot_product_ret(evals_on_data, unvariate_selectors_evals, 2**UNIVARIATE_SKIPS, EE);
        all_bus_statements_denominators_claims.push(univariate_value_on_data);

        offset += n_rows;
        
        // II] Lookup into memory

        columns_values.push(vec![]);
        total_num_cols = NUM_COLS_F_AIR[table_index] + DIM * NUM_COLS_EF_AIR[table_index];
        for col in 0..total_num_cols unroll {
            columns_values[table_index].push(vec![]);
        }

        for lookup_f_index in 0..len(LOOKUPS_F_INDEXES[table_index]) unroll {
            col_index = LOOKUPS_F_INDEXES[table_index][lookup_f_index];
            fs, index_eval = fs_receive_ef(fs, 1);
            debug_assert len(columns_values[table_index][col_index]) == 0;
            columns_values[table_index][col_index].push(index_eval);
            for i in 0..len(LOOKUPS_F_VALUES[table_index][lookup_f_index]) unroll {
                fs, value_eval = fs_receive_ef(fs, 1);
                col_index = LOOKUPS_F_VALUES[table_index][lookup_f_index][i];
                debug_assert len(columns_values[table_index][col_index]) == 0;
                columns_values[table_index][col_index].push(value_eval);

                prefix = multilinear_location_prefix(offset / n_rows, N_VARS_FIRST_GKR - log_n_rows, point_gkr); // TODO there is some duplication here
                // TODO

                offset += n_rows;
            }
        }

        return;
    }

    return;
}

fn eval_all_univariate_selectors(a) -> 1 {
    a_powers = powers_const(a, 2**UNIVARIATE_SKIPS);
    res = malloc(DIM * 2**UNIVARIATE_SKIPS);
    for i in 0..2**UNIVARIATE_SKIPS unroll {
        selector_poly = pointer_to_univariate_selectors + i * 2**UNIVARIATE_SKIPS;
        dot_product(selector_poly, a_powers, res + i * DIM, 2**UNIVARIATE_SKIPS, BE);
    }
    return res;
}

fn multilinear_location_prefix(offset, n_vars, point) -> 1 {
    bits = checked_decompose_bits_small_value(offset, n_vars);
    res = eq_mle_extension_base(bits, point, n_vars);
    return res;
}

fn fingerprint_2(table_index, data_1, data_2, alpha_powers) -> 1 {
    res1 = mul_extension_ret(data_1, alpha_powers + DIM);
    res2 = mul_extension_ret(data_2, alpha_powers + 2 * DIM);
    res3 = add_extension_ret(res1, res2);
    res4 = add_base_extension_ret(table_index, res3);
    return res4;
}

fn verify_gkr_quotient(mut fs, n_vars) -> 5 {
    fs, nums = fs_receive_ef(fs, 2);
    fs, denoms = fs_receive_ef(fs, 2);

    q1 = div_extension(nums, denoms);
    q2 = div_extension(nums + DIM, denoms + DIM);
    quotient = add_extension_ret(q1, q2);

    points = malloc(n_vars);
    claims_num = malloc(n_vars);
    claims_den = malloc(n_vars);

    points[0] = fs_sample_ef(fs);
    fs = duplexing(fs);

    point_poly_eq = poly_eq_extension(points[0], 1);

    first_claim_num = dot_product_ret(nums, point_poly_eq, 2, EE);
    first_claim_den = dot_product_ret(denoms, point_poly_eq, 2, EE);
    claims_num[0] = first_claim_num;
    claims_den[0] = first_claim_den;

    for i in 1..n_vars {
        fs, points[i], claims_num[i], claims_den[i] = verify_gkr_quotient_step(fs, i, points[i - 1], claims_num[i - 1], claims_den[i - 1]);
    }

    return fs, quotient, points[n_vars - 1], claims_num[n_vars - 1], claims_den[n_vars - 1];
}

fn verify_gkr_quotient_step(mut fs, n_vars, point, claim_num, claim_den) -> 4 {
    alpha = fs_sample_ef(fs);
    alpha_mul_claim_den = mul_extension_ret(alpha, claim_den);
    num_plus_alpha_mul_claim_den = add_extension_ret(claim_num, alpha_mul_claim_den);
    postponed_point = malloc((n_vars + 1) * DIM);
    fs, postponed_value = sumcheck_verify_helper(fs, n_vars, num_plus_alpha_mul_claim_den, 3, postponed_point + DIM);
    fs, inner_evals = fs_receive_ef(fs, 4);
    a_num = inner_evals;
    b_num = inner_evals + DIM;
    a_den = inner_evals + 2 * DIM;
    b_den = inner_evals + 3 * DIM;
    sum_num, sum_den = sum_2_ef_fractions(a_num, a_den, b_num, b_den);
    sum_den_mul_alpha = mul_extension_ret(sum_den, alpha);
    sum_num_plus_sum_den_mul_alpha = add_extension_ret(sum_num, sum_den_mul_alpha);
    eq_factor = eq_mle_extension(point, postponed_point + DIM, n_vars);
    mul_extension(sum_num_plus_sum_den_mul_alpha, eq_factor, postponed_value);

    beta = fs_sample_ef(fs);
    fs = duplexing(fs);
    point_poly_eq = poly_eq_extension(beta, 1);
    new_claim_num = dot_product_ret(inner_evals, point_poly_eq, 2, EE);
    new_claim_den = dot_product_ret(inner_evals + 2 * DIM, point_poly_eq, 2, EE);

    copy_5(beta, postponed_point);

    return fs, postponed_point, new_claim_num, new_claim_den;

}
