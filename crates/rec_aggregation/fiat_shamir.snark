// FIAT SHAMIR layout: 17 field elements
// 0..8 -> first half of sponge state
// 8..16 -> second half of sponge state
// 16 -> transcript pointer

import "utils.snark";

fn fs_new(transcript_ptr) -> 1 {
    fs_state = malloc(17);
    set_to_16_zeros(fs_state);
    fs_state[16] = transcript_ptr;
    duplexed = duplexing(fs_state);
    return duplexed;
}

fn duplexing(fs) -> 1 {
    new_fs = malloc(17);
    poseidon16(fs, fs + 8, new_fs, PERMUTATION);
    new_fs[16] = fs[16];
    return new_fs;
}

fn fs_grinding(fs, bits) -> 1 {
    if bits == 0 {
        return fs; // no grinding
    }
    left = malloc(8);
    grinding_witness = read_memory(fs[16]);
    left[0] = grinding_witness;
    set_to_7_zeros(left + 1);

    fs_1 = malloc(17);
    poseidon16(left, fs + 8, fs_1, PERMUTATION);
    fs_1[16] = fs[16] + 1; // one element read from transcript

    sampled = fs_1[0];
    _, sampled_low_bits_value = checked_decompose_bits(sampled, bits);
    assert sampled_low_bits_value == 0;

    fs_2 = duplexing(fs_1);
    
    return fs_2;
}

fn fs_sample_ef(fs) -> 2 {
    return fs, fs;
}

fn fs_hint(fs, n) -> 2 {
    // return the updated fiat-shamir, and a pointer to n field elements from the transcript

    transcript_ptr = fs[16];
    new_fs = malloc(17);
    copy_16(fs, new_fs);
    new_fs[16] = fs[16] + n; // advance transcript pointer
    return new_fs, transcript_ptr;
}

fn fs_receive_chunks(fs, const n_chunks) -> 2 {
    // each chunk = 8 field elements
    new_fs = malloc(1 + 16 * n_chunks);
    transcript_ptr = fs[16];
    new_fs[16 * n_chunks] = transcript_ptr + 8 * n_chunks; // advance transcript pointer

    poseidon16(transcript_ptr, fs + 8, new_fs, PERMUTATION);
    for i in 1..n_chunks unroll {
        poseidon16(transcript_ptr + i * 8, new_fs + ((i-1) * 16 + 8), new_fs + i * 16, PERMUTATION);
    }
    return new_fs + 16 * (n_chunks - 1), transcript_ptr;
}

fn fs_receive_ef(fs, const n) -> 2 {
    new_fs, ef_ptr = fs_receive_chunks(fs, next_multiple_of(n * DIM, 8) / 8);
    for i in n * DIM..next_multiple_of(n * DIM, 8) unroll {
        assert ef_ptr[i] == 0;
    }
    return new_fs, ef_ptr;
}


fn fs_print_state(fs_state) {
    for i in 0..17 unroll {
        print(i, fs_state[i]);
    }
    return;
}

fn sample_bits_const(fs, const n_samples, K) -> 2 {
    // return the updated fiat-shamir, and a pointer to n pointers, each pointing to 31 (boolean) field elements,
    all_fs = malloc(1 + next_multiple_of(n_samples, 8) / 8);
    all_fs[0] = fs;
    for i in 0..next_multiple_of(n_samples, 8) / 8 unroll {
        duplexed = duplexing(all_fs[i]);
        all_fs[i + 1] = duplexed;
    }
    sampled_bits = malloc(n_samples);
    for i in 0..(next_multiple_of(n_samples, 8) / 8) - 1 unroll {
        my_fs = all_fs[i];
        for j in 0..8 unroll {
            bits, _ = checked_decompose_bits(my_fs[j], K);
            sampled_bits[i * 8 + j] = bits;
        }
    }
    // Last batch (may be partial)
    last_fs = all_fs[(next_multiple_of(n_samples, 8) / 8) - 1];
    for j in 0..(n_samples % 8) unroll {
        bits, _ = checked_decompose_bits(last_fs[j], K);
        sampled_bits[((next_multiple_of(n_samples, 8) / 8) - 1) * 8 + j] = bits;
    }
    final_fs = duplexing(last_fs);

    return final_fs, sampled_bits;
}


fn sample_bits_dynamic(fs_state, n_samples, K) -> 2 {
    var new_fs_state;
    var sampled_bits;
    for r in 0..N_ROUNDS + 1 unroll {
        if n_samples == NUM_QUERIES[r] {
            new_fs_state, sampled_bits = sample_bits_const(fs_state, NUM_QUERIES[r], K);
            return new_fs_state, sampled_bits;
        }
    }
    print(n_samples);
    print(999333);
    panic();
}