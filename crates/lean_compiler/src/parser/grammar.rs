use pest::Parser;
use pest_derive::Parser;

/// Main parser struct generated by Pest.
#[derive(Parser)]
#[grammar = "grammar.pest"]
pub struct LangParser;

pub use pest::iterators::Pair;

/// Type alias for a parsed grammar rule.
pub type ParsePair<'i> = Pair<'i, Rule>;

/// Utility function to get the line and column number from a parse pair.
///
/// This is useful for error reporting and source location tracking.
pub fn get_location(pair: &ParsePair<'_>) -> (usize, usize) {
    pair.line_col()
}

/// Utility function to safely get the next inner element from a parser.
pub fn next_inner<'i>(
    mut pairs: impl Iterator<Item = ParsePair<'i>>,
    expected: &str,
) -> Option<ParsePair<'i>> {
    pairs.next().or_else(|| {
        eprintln!("Warning: Expected {} but found nothing", expected);
        None
    })
}

/// Utility function to parse the main program structure.
pub fn parse_source(input: &str) -> Result<ParsePair<'_>, Box<pest::error::Error<Rule>>> {
    let mut pairs = LangParser::parse(Rule::program, input)?;
    Ok(pairs.next().unwrap())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_location() {
        let input = "fn main() {}";
        if let Ok(pair) = parse_source(input) {
            let (line, col) = get_location(&pair);
            assert_eq!(line, 1);
            assert_eq!(col, 1);
        }
    }

    #[test]
    fn test_next_inner_found() {
        let input = "fn main() {}";
        if let Ok(pair) = parse_source(input) {
            let mut inner = pair.into_inner();
            let result = next_inner(&mut inner, "function");
            assert!(result.is_some());
        }
    }

    #[test]
    fn test_next_inner_not_found() {
        let empty_iter = std::iter::empty();
        let result = next_inner(empty_iter, "missing");
        assert!(result.is_none());
    }

    #[test]
    fn test_parse_source_valid() {
        let input = "fn main() {}";
        let result = parse_source(input);
        assert!(result.is_ok());
        if let Ok(pair) = result {
            assert_eq!(pair.as_rule(), Rule::program);
        }
    }

    #[test]
    fn test_parse_source_invalid() {
        let input = "invalid syntax $%@";
        let result = parse_source(input);
        assert!(result.is_err());
    }
}
