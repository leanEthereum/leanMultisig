use crate::codegen::function::compile_function;
use crate::{ir::*, lang::*};
use lean_vm::*;
use std::collections::BTreeMap;

/// Main compiler state container.
#[derive(Debug, Default)]
pub struct Compiler {
    /// Generated bytecode organized by function labels.
    pub bytecode: BTreeMap<Label, Vec<IntermediateInstruction>>,
    /// Match statement bytecode blocks (each match = many bytecode blocks, each bytecode block = many instructions).
    pub match_blocks: Vec<Vec<Vec<IntermediateInstruction>>>,
    /// Counter for generating unique if statement labels.
    pub if_counter: usize,
    /// Counter for generating unique function call labels.
    pub call_counter: usize,
    /// Name of the current function being compiled.
    pub func_name: String,
    /// Variable positions in the stack frame (var -> memory offset from fp).
    pub var_positions: BTreeMap<Var, usize>,
    /// Number of function arguments for current function.
    pub args_count: usize,
    /// Total stack frame size for current function.
    pub stack_size: usize,
    /// Const malloc allocations (const_malloc_label -> start = memory offset from fp).
    pub const_mallocs: BTreeMap<ConstMallocLabel, usize>,
}

impl Compiler {
    /// Creates a new compiler instance.
    pub fn new() -> Self {
        Self::default()
    }

    /// Compiles a complete program to intermediate bytecode.
    pub fn compile_program(
        &mut self,
        simple_program: SimpleProgram,
    ) -> Result<IntermediateBytecode, String> {
        let mut memory_sizes = BTreeMap::new();

        for function in simple_program.functions.values() {
            let instructions = compile_function(function, self)?;
            self.bytecode
                .insert(Label::function(&function.name), instructions);
            memory_sizes.insert(function.name.clone(), self.stack_size);
        }

        Ok(IntermediateBytecode {
            bytecode: self.bytecode.clone(),
            match_blocks: self.match_blocks.clone(),
            memory_size_per_function: memory_sizes,
        })
    }

    /// Gets the memory offset for a variable or const malloc access.
    pub fn get_offset(&self, var: &VarOrConstMallocAccess) -> ConstExpression {
        match var {
            VarOrConstMallocAccess::Var(var) => (*self
                .var_positions
                .get(var)
                .unwrap_or_else(|| panic!("Variable {var} not in scope")))
            .into(),
            VarOrConstMallocAccess::ConstMallocAccess {
                malloc_label,
                offset,
            } => ConstExpression::Binary {
                left: Box::new(
                    self.const_mallocs
                        .get(malloc_label)
                        .copied()
                        .unwrap_or_else(|| panic!("Const malloc {malloc_label} not in scope"))
                        .into(),
                ),
                operation: HighLevelOperation::Add,
                right: Box::new(offset.clone()),
            },
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ir::{SimpleFunction, SimpleLine, VarOrConstMallocAccess};
    use crate::lang::SimpleExpr;

    #[test]
    fn test_compiler_creation() {
        let compiler = Compiler::new();
        assert!(compiler.bytecode.is_empty());
        assert!(compiler.match_blocks.is_empty());
        assert_eq!(compiler.if_counter, 0);
        assert_eq!(compiler.call_counter, 0);
    }

    #[test]
    fn test_compiler_compile_function() {
        let mut compiler = Compiler::new();
        let function = SimpleFunction {
            name: "test".to_string(),
            arguments: vec!["x".to_string(), "y".to_string()],
            instructions: vec![SimpleLine::Assignment {
                var: VarOrConstMallocAccess::Var("result".to_string()),
                operation: HighLevelOperation::Add,
                arg0: SimpleExpr::Var("x".to_string()),
                arg1: SimpleExpr::Var("y".to_string()),
            }],
            n_returned_vars: 1,
        };

        let result = compile_function(&function, &mut compiler);
        assert!(result.is_ok());

        assert_eq!(compiler.func_name, "test");
        assert_eq!(compiler.args_count, 2);
        assert!(compiler.var_positions.contains_key("x"));
        assert!(compiler.var_positions.contains_key("y"));
        assert!(compiler.var_positions.contains_key("result"));
        assert!(compiler.stack_size > 2); // At least pc + fp + args
    }

    #[test]
    fn test_compiler_counter_access() {
        let mut compiler = Compiler::new();

        // Test counter initialization
        assert_eq!(compiler.if_counter, 0);
        assert_eq!(compiler.call_counter, 0);

        // Test counter modification
        compiler.if_counter = 5;
        compiler.call_counter = 3;
        assert_eq!(compiler.if_counter, 5);
        assert_eq!(compiler.call_counter, 3);
    }

    #[test]
    fn test_compiler_offset_calculation() {
        let mut compiler = Compiler::new();
        compiler.func_name = "test".to_string();
        compiler.args_count = 0;
        compiler.stack_size = 10;

        compiler.var_positions.insert("x".to_string(), 5);
        compiler.const_mallocs.insert(0, 8);

        // Test variable offset
        let var_access = VarOrConstMallocAccess::Var("x".to_string());
        let offset = compiler.get_offset(&var_access);
        assert_eq!(offset, ConstExpression::scalar(5));

        // Test const malloc offset
        let malloc_access = VarOrConstMallocAccess::ConstMallocAccess {
            malloc_label: 0,
            offset: ConstExpression::scalar(3),
        };
        let offset = compiler.get_offset(&malloc_access);
        if let ConstExpression::Binary {
            operation,
            left,
            right,
        } = offset
        {
            assert_eq!(operation, HighLevelOperation::Add);
            assert_eq!(left.as_ref(), &ConstExpression::scalar(8));
            assert_eq!(right.as_ref(), &ConstExpression::scalar(3));
        } else {
            panic!("Expected binary expression");
        }
    }

    #[test]
    fn test_compiler_stack_allocation() {
        let mut compiler = Compiler::new();
        compiler.func_name = "test".to_string();
        compiler.args_count = 0;
        compiler.stack_size = 10;

        // Test that we can modify stack size
        let initial_size = compiler.stack_size;
        compiler.stack_size += 5;
        assert_eq!(compiler.stack_size, initial_size + 5);
    }
}
