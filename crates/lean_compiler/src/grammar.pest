WHITESPACE = _{ " " | "\t" | "\n" | "\r" }

// Program structure
program = { SOI ~ import_statement* ~ constant_declaration* ~ function* ~ EOI }

// Imports
import_statement = { "import" ~ filepath ~ ";" }

// Constants
constant_declaration = { "const" ~ identifier ~ "=" ~ (array_literal | expression) ~ ";" }
array_literal = { "[" ~ (array_element ~ ("," ~ array_element)*)? ~ "]" }
array_element = { array_literal | expression }

// Functions
function = { pragma? ~ "fn" ~ identifier ~ "(" ~ parameter_list? ~ ")" ~ inlined_statement? ~ return_count? ~ "{" ~ statement* ~ "}" }
pragma = { "#![assume_always_returns]" }
parameter_list = { parameter ~ ("," ~ parameter)* }
parameter = { const_keyword? ~ mut_keyword? ~ identifier }
const_keyword = { "const" }
inlined_statement = { "inline" }
return_count = { "->" ~ number }

// Statements
statement = {
    forward_declaration |
    if_statement |
    for_statement |
    match_statement |
    return_statement |
    break_statement |
    continue_statement |
    assert_statement |
    debug_assert_statement |
    assignment
}

return_statement = { "return" ~ (tuple_expression)? ~ ";" }

break_statement = { "break" ~ ";" }
continue_statement = { "continue" ~ ";" }

mut_keyword = @{ "mut" ~ !(ASCII_ALPHANUMERIC | "_") }

forward_declaration = { "var" ~ mut_keyword? ~ identifier ~ ";" }

// General assignment: LHS is optional list of variables/array accesses, RHS is any expression
assignment = { (assignment_target_list ~ "=")? ~ expression ~ ";" }
assignment_target_list = { assignment_target ~ ("," ~ assignment_target)* }
assignment_target = { (mut_keyword ~ identifier) | array_access_expr | identifier }

if_statement = { "if" ~ condition ~ "{" ~ statement* ~ "}" ~ else_if_clause* ~ else_clause? }

condition = { assumed_bool_expr | comparison }

assumed_bool_expr = { "!!assume_bool" ~ "(" ~ expression ~ ")" }

// Comparisons (shared between conditions and assertions)
comparison = { add_expr ~ comparison_op ~ add_expr }
comparison_op = { "==" | "!=" | "<" }

else_if_clause = { "else" ~ "if" ~ condition ~ "{" ~ statement* ~ "}" }

else_clause = { "else" ~ "{" ~ statement* ~ "}" }

for_statement = { "for" ~ identifier ~ "in" ~ rev_clause? ~ expression ~ ".." ~ expression ~ unroll_clause? ~ "{" ~ statement* ~ "}" }
rev_clause = { "rev" }
unroll_clause = { "unroll" }

match_statement = { "match" ~ expression ~ "{" ~ match_arm* ~ "}" }
match_arm = { pattern ~ "=>" ~ "{" ~ statement* ~ "}" }
pattern = { constant_value }

assert_statement = { "assert" ~ comparison ~ ";" }
debug_assert_statement = { "debug_assert" ~ comparison ~ ";" }

// Expressions
tuple_expression = { expression ~ ("," ~ expression)* }
expression = { add_expr }
add_expr = { sub_expr ~ ("+" ~ sub_expr)* }
sub_expr = { mul_expr ~ ("-" ~ mul_expr)* }
mul_expr = { mod_expr ~ ("*" ~ mod_expr)* }
mod_expr = { div_expr ~ ("%" ~ div_expr)* }
div_expr = { exp_expr ~ ("/" ~ exp_expr)* }
exp_expr = { primary ~ ("**" ~ primary)* }
primary = {
    "(" ~ expression ~ ")" |
    log2_ceil_expr |
    next_multiple_of_expr |
    saturating_sub_expr |
    len_expr |
    array_access_expr |
    function_call_expr |
    var_or_constant
}
function_call_expr = { identifier ~ "(" ~ tuple_expression? ~ ")" }
log2_ceil_expr = { "log2_ceil" ~ "(" ~ expression ~ ")" }
next_multiple_of_expr = { "next_multiple_of" ~ "(" ~ expression ~ "," ~ expression ~ ")" }
saturating_sub_expr = { "saturating_sub" ~ "(" ~ expression ~ "," ~ expression ~ ")" }
len_expr = { "len" ~ "(" ~ len_argument ~ ")" }
len_argument = { identifier ~ ("[" ~ expression ~ "]")* }
array_access_expr = { identifier ~ ("[" ~ expression ~ "]")+ }

// Basic elements
var_or_constant = { constant_value | identifier }
constant_value = { number | "public_input_start" | "pointer_to_zero_vector" | "pointer_to_one_vector" }

// Lexical elements
identifier = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
number = @{ ASCII_DIGIT+ }
filepath = { "\"" ~ filepath_character* ~ "\"" }
filepath_character = { ASCII_ALPHANUMERIC | "-" | "_" | " " | "." | "+" | "/" }
