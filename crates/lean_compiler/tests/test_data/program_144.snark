// Comprehensive tests for mutable variables with early exits (panic/return) in branches.
// This tests the SSA transformation when branches end with panic() or return.
// Bug fix: ensure proper handling of mutable variable unification when some branches exit early.

fn main() {
    // ==========================================================================
    // TEST 1: Basic - panic in else branch (the original bug case)
    // ==========================================================================
    var two;
    if 1 == 1 {
        two = 2;
    } else {
        panic();
    }
    assert two == 2;

    // ==========================================================================
    // TEST 2: panic in then branch
    // ==========================================================================
    var three;
    if 1 != 1 {
        panic();
    } else {
        three = 3;
    }
    assert three == 3;

    // ==========================================================================
    // TEST 3: Multiple mutable variables, panic in else
    // ==========================================================================
    var a;
    var b;
    var c;
    if 1 == 1 {
        a = 10;
        b = 20;
        c = 30;
    } else {
        panic();
    }
    assert a == 10;
    assert b == 20;
    assert c == 30;

    // ==========================================================================
    // TEST 4: Nested if with panic in inner else
    // ==========================================================================
    var x;
    if 1 == 1 {
        if 2 == 2 {
            x = 42;
        } else {
            panic();
        }
    } else {
        panic();
    }
    assert x == 42;

    // ==========================================================================
    // TEST 5: Mutable var modified in then, panic in else
    // ==========================================================================
    mut counter = 0;
    if 1 == 1 {
        counter = counter + 5;
    } else {
        panic();
    }
    assert counter == 5;

    // ==========================================================================
    // TEST 6: Multiple modifications before panic check
    // ==========================================================================
    mut val = 1;
    val = val * 2;
    val = val + 3;
    if val == 5 {
        val = val * 10;
    } else {
        panic();
    }
    assert val == 50;

    // ==========================================================================
    // TEST 7: Chain of else-if with panic in final else
    // ==========================================================================
    var result;
    selector = 1;
    if selector == 0 {
        result = 100;
    } else if selector == 1 {
        result = 200;
    } else if selector == 2 {
        result = 300;
    } else {
        panic();
    }
    assert result == 200;

    // ==========================================================================
    // TEST 8: Match with panic in one arm
    // ==========================================================================
    var matched;
    tag = 1;
    match tag {
        0 => { panic(); }
        1 => { matched = 111; }
        2 => { panic(); }
    }
    assert matched == 111;

    // ==========================================================================
    // TEST 9: Match where only one arm doesn't panic
    // ==========================================================================
    var only_valid;
    tag2 = 2;
    match tag2 {
        0 => { panic(); }
        1 => { panic(); }
        2 => { only_valid = 222; }
        3 => { panic(); }
    }
    assert only_valid == 222;

    // ==========================================================================
    // TEST 10: Panic in deeply nested structure
    // ==========================================================================
    var deep;
    if 1 == 1 {
        if 1 == 1 {
            if 1 == 1 {
                deep = 999;
            } else {
                panic();
            }
        } else {
            panic();
        }
    } else {
        panic();
    }
    assert deep == 999;

    // ==========================================================================
    // TEST 11: Mutable var used after branch with panic
    // ==========================================================================
    mut acc = 0;
    for i in 0..3 unroll {
        if 1 == 1 {
            acc = acc + i;
        } else {
            panic();
        }
    }
    assert acc == 3;

    // ==========================================================================
    // TEST 12: Forward declared var with panic in branch
    // ==========================================================================
    var fwd;
    cond = 1;
    if cond == 1 {
        fwd = 777;
    } else {
        panic();
    }
    assert fwd == 777;

    // ==========================================================================
    // TEST 13: Both mutable and immutable forward decl with panic
    // ==========================================================================
    var imm;
    var mtbl;
    flag = 0;
    if flag == 0 {
        imm = 100;
        mtbl = 200;
    } else {
        panic();
    }
    mut mtbl2 = mtbl;
    mtbl2 = mtbl2 + 50;
    assert imm == 100;
    assert mtbl2 == 250;

    // ==========================================================================
    // TEST 14: Return in function branch (early exit)
    // ==========================================================================
    res14 = test_early_return(1);
    assert res14 == 10;
    res14b = test_early_return(0);
    assert res14b == 20;

    // ==========================================================================
    // TEST 15: Multiple mutable vars with return in branch
    // ==========================================================================
    r15a, r15b = test_multi_return(1);
    assert r15a == 100;
    assert r15b == 200;

    // ==========================================================================
    // TEST 16: Mutable var with panic in match, then more operations
    // ==========================================================================
    mut m16 = 5;
    sel16 = 0;
    match sel16 {
        0 => { m16 = m16 * 2; }
        1 => { panic(); }
    }
    m16 = m16 + 3;
    assert m16 == 13;

    // ==========================================================================
    // TEST 17: Nested match with panic
    // ==========================================================================
    var nested_match;
    outer = 1;
    match outer {
        0 => { panic(); }
        1 => {
            inner = 0;
            match inner {
                0 => { nested_match = 500; }
                1 => { panic(); }
            }
        }
    }
    assert nested_match == 500;

    // ==========================================================================
    // TEST 18: If inside match with panic
    // ==========================================================================
    var if_in_match;
    m18_sel = 0;
    match m18_sel {
        0 => {
            cond18 = 1;
            if cond18 == 1 {
                if_in_match = 600;
            } else {
                panic();
            }
        }
        1 => { panic(); }
    }
    assert if_in_match == 600;

    // ==========================================================================
    // TEST 19: Match inside if with panic
    // ==========================================================================
    var match_in_if;
    cond19 = 1;
    if cond19 == 1 {
        tag19 = 1;
        match tag19 {
            0 => { panic(); }
            1 => { match_in_if = 700; }
        }
    } else {
        panic();
    }
    assert match_in_if == 700;

    // ==========================================================================
    // TEST 20: Panic after partial assignment
    // ==========================================================================
    var partial;
    check = 0;
    if check == 0 {
        mut partial_tmp = 1;
        partial_tmp = partial_tmp + 1;
        partial_tmp = partial_tmp * 2;
        partial = partial_tmp;
    } else {
        partial = 999;
        panic();
    }
    assert partial == 4;

    // ==========================================================================
    // TEST 21: Unrolled loop with panic in branch at each iteration
    // ==========================================================================
    mut sum21 = 0;
    for i in 0..5 unroll {
        expected = i;
        if i == expected {
            sum21 = sum21 + i;
        } else {
            panic();
        }
    }
    assert sum21 == 10;

    // ==========================================================================
    // TEST 22: Function with mutable param and early return
    // ==========================================================================
    res22 = func_with_mut_param(5, 1);
    assert res22 == 50;

    // ==========================================================================
    // TEST 23: Multiple levels - if/match/if with panics
    // ==========================================================================
    var multi_level;
    c1 = 1;
    if c1 == 1 {
        s1 = 0;
        match s1 {
            0 => {
                c2 = 0;
                if c2 == 0 {
                    multi_level = 888;
                } else {
                    panic();
                }
            }
            1 => { panic(); }
        }
    } else {
        panic();
    }
    assert multi_level == 888;

    // ==========================================================================
    // TEST 24: Panic in both outer branches but inner assigns
    // ==========================================================================
    var inner_assigns;
    outer24 = 0;
    match outer24 {
        0 => {
            inner24 = 1;
            if inner24 == 1 {
                inner_assigns = 1000;
            } else {
                panic();
            }
        }
        1 => { panic(); }
    }
    assert inner_assigns == 1000;

    // ==========================================================================
    // TEST 25: Complex - multiple vars, nested, with panics
    // ==========================================================================
    var va;
    var vb;
    var vc;

    outer25 = 1;
    if outer25 == 1 {
        va = 1;
        mid25 = 0;
        match mid25 {
            0 => {
                vb = 2;
                inner25 = 1;
                if inner25 == 1 {
                    vc = 3;
                } else {
                    panic();
                }
            }
            1 => { panic(); }
        }
    } else {
        panic();
    }

    total = va + vb + vc;
    assert total == 6;

    return;
}

// Helper function for TEST 14
fn test_early_return(flag) -> 1 {
    var result;
    if flag == 1 {
        result = 10;
    } else {
        result = 20;
    }
    return result;
}

// Helper function for TEST 15
fn test_multi_return(flag) -> 2 {
    var a;
    var b;
    if flag == 1 {
        a = 100;
        b = 200;
    } else {
        panic();
    }
    return a, b;
}

// Helper function for TEST 22
fn func_with_mut_param(mut x, flag) -> 1 {
    if flag == 1 {
        x = x * 10;
    } else {
        panic();
    }
    return x;
}
