fn main() {
    level1_acc, level2_acc, level3_acc, level4_acc = quad_nested_accumulators();
    assert level1_acc == 2;
    assert level2_acc == 6;
    assert level3_acc == 12;
    assert level4_acc == 24;

    result2 = nested_conditional_sum();
    assert result2 == 56;

    result3 = rev_forward_sum();
    assert result3 == 17;

    arr = malloc(27);
    mut write_idx = 0;

    for i in 0..3 unroll {
        for j in 0..3 unroll {
            for k in 0..3 unroll {
                arr[write_idx] = i * 9 + j * 3 + k;
                write_idx = write_idx + 1;
            }
        }
    }

    assert write_idx == 27;
    assert arr[0] == 0;
    assert arr[13] == 13;
    assert arr[26] == 26;

    result6 = double_nested_with_func();
    assert result6 == 36;

    return;
}

fn quad_nested_accumulators() -> 4 {
    mut l1 = 0;
    mut l2 = 0;
    mut l3 = 0;
    mut l4 = 0;

    for a in 0..2 unroll {
        l1 = l1 + 1;
        for b in 0..3 unroll {
            l2 = l2 + 1;
            for c in 0..2 unroll {
                l3 = l3 + 1;
                for d in 0..2 unroll {
                    l4 = l4 + 1;
                }
            }
        }
    }

    return l1, l2, l3, l4;
}

fn nested_conditional_sum() -> 1 {
    mut sum = 0;

    for i in 0..3 unroll {
        for j in 0..4 unroll {
            for k in 0..2 unroll {
                if i == 0 {
                    sum = sum + j + k;
                } else if i == 1 {
                    sum = sum + j;
                } else {
                    sum = sum + i * j + k;
                }
            }
        }
    }

    return sum;
}

fn rev_forward_sum() -> 1 {
    mut product_sum = 0;
    mut index_sum = 0;

    for i in rev 0..3 unroll {
        for j in 0..3 unroll {
            if i == j {
                product_sum = product_sum + i * j;
            } else {
                index_sum = index_sum + i + j;
            }
        }
    }

    return product_sum + index_sum;
}

fn double_nested_with_func() -> 1 {
    mut total = 0;
    for i in 0..3 unroll {
        for j in 0..3 unroll {
            contribution = compute_contrib(i, j);
            total = total + contribution;
        }
    }
    return total;
}

fn compute_contrib(i, j) -> 1 {
    return (i + 1) * (j + 1);
}
